라라벨

친절한 설명 , but not detail

https://tutorials.kode-blog.com/laravel-install-and-configure

https://tutorials.kode-blog.com/laravel-hello-world

불친절한 설명 , but detail

https://laravel.kr/docs/5.6/installation

----------------------------------------

Public 디렉토리
라라벨을 설치후에 어플리케이션의 document / web 루트를 public 디렉토리로 설정해야 합니다. 이 디렉토리의 index.php는 어플리케이션의 모든 HTTP 요청에 대해서 프론트 컨트롤러로 작동합니다.

설정 파일
라라벨 프레임워크의 모든 설정 파일들은 config 디렉토리에 위치합니다. 각각의 옵션들은 문서가 작성되어 있으며, 사용 가능한 옵션들을 이해하기 위해서 전체 문서들을 둘러보는 것이 좋습니다.

디렉토리 권한 설정
라라벨을 설치한 뒤에, 몇몇 권한을 설정해야될 필요가 있습니다. storage 와 bootstrap/cache 디렉토리 안에 들어 있는 디렉토리들은 모두 웹 서버에 의해서 쓰기가 가능해야 합니다. 그렇지 않으면 라라벨이 실행되지 않습니다. 홈스테드를 사용중이라면 이미 권한이 설정되어 있을 것입니다.

어플리케이션 키 설정
라라벨 설치 후 해야할 일은 여러분의 어플리케이션 키를 랜덤한 문자열로 세팅하는 것입니다. 만약 라라벨이 Composer 를 통해서 설치되었다면 키는 php artisan key:generate 명령어가 실행되어 이미 설정되어 있을 것입니다.

일반적으로, 이 키는 32자리의 문자열입니다. 이 키는 .env 환경설정 파일에서 세팅할 수 있습니다. 아직 .env.example 파일을 .env 로 변경하지 않았다면 지금 변경합니다. 만약 어플리케이션 키가 세팅되어있지 않다면, 여러분의 사용자 세션과 그밖의 암호화된 데이터들이 안전하지 않습니다!

추가적인 설정
라라벨은 앞의 내용 이외의 다른 세팅은 거의 필요 하지 않습니다. 이제 편하게 개발을 시작하면 됩니다! 그러나 가급적 config/app.php 파일의 내용을 살펴보길 권장합니다. timezone과 locale과 같이 여러분의 어플리케이션을 따라 바꾸기를 원하는 몇가지 옵션들을 포함하고 있습니다.

다음과 같은 라라벨의 컴포넌트들에 대한 몇가지 설정들을 해둘 수도 있습니다.

Cache -  https://laravel.kr/docs/5.6/cache#configuration
Database - https://laravel.kr/docs/5.6/database#configuration
Session  - https://laravel.kr/docs/5.6/session#configuration

------------------------------------------------

설정 캐시
어플리케이션의 구동 속도를 더 빠르게 하려면, config:cache 아티즌 명령어를 통해서 설정 파일들을 하나로 묶어 캐싱해야 합니다. 이 명령어는 모든 설정 옵션을 하나의 파일로 묶어 어플리케이션이 빠르게 로드할 수 있게 해줍니다.

일반적으로 php artisan config:cache 명령어를 어플리케이션 배포 루틴의 일부에서 실행하도록 해야 합니다. 어플리케이션 개발 중에는 설정 옵션값이 자주 바뀔 필요가 있기 때문에, 로컬 개발 환경에서는 이 명령어를 실행하지 말아야 합니다.

{note} 배포가 진행 되는 도중에 config:cache 명령어를 실행한다면, 설정 파일안에서 env 함수만 호출된다는 것을 확인해야 합니다. 한번, 설정이 캐싱되고 나면, .env 파일은 로딩되지 않고, 모든 env 함수는 null을 반환합니다.

* 로컬 개발 환경에서는 이 명령어를 실행하지 않는다.

--------------------------------

점검모드

cmd창에서 php artisan down -> 점검 모드

php artisan up -> 점검 모드 해제

{tip} resources/views/errors/503.blade.php 파일을 정의해서 점검모드의 응답페이지 템플릿을 커스터마이징 할 수 있습니다.

------------------------------

모델 디렉토리는 어디에 있나요?
라라벨을 시작할 때, 많은 개발자들이 models 디렉토리가 없는 것에 혼란을 느낍니다. 하지만 이 디렉토리가 없는 것은 의도된 것입니다. 우리는 "모델"이라는 많은 사람들에게 각기 다른 의미로 받아들려지기 때문에 모호하다는 것을 알게되었습니다. 일부 개발자들은 어플리케이션의 "모델"을 비지니스 로직의 전체로서 참조하는 반면, 다른 개발자들은 "모델"을 관계형 데이터베이스와 상호작용하는데 사용합니다.

이러한 이유로, 기본적으로 app 디렉토리를 Eloquent 모델이 저장되는 곳으로 선택했으며, 개발자가 원하는 그 어떤 곳이라도 이 파일들을 배치할 수 있게 허용 하고 있습니다.

root 디렉토리 관련

Public 디렉토리
public 디렉토리는 어플리케이션에 진입하는 모든 request-요청들에 대한 진입점 역할과 오토로딩을 설정하는 index.php 파일을 가지고 있습니다. 이 디렉토리는 이미지나 자바스크립트, CSS와 같은 asset파일들을도 포함되어 있습니다.

Bootstrap 디렉토리
bootstrap 디렉토리는 프레임워크의 부트스트래핑을 담당하는 app.php 파일을 가지고 있습니다. 또한 프레임워크가 라우트나 서비스 캐시 파일과 같은 퍼포먼스 향상을 위해서 생성하는 cache 디렉토리를 가지고 있습니다.

---------------------------------

App 디렉토리 관련

app 디렉토리는 Console, Http 그리고 Providers 와 같은 다양한 추가 디렉토리를 가지고 있습니다. Console 과 Http 디렉토리는 어플리케이션의 코어에 API를 제공하고 있다고 생각할 수 있습니다.

HTTP 프로토콜과 CLI 모두 어플리케이션과 상호작용하는 매커니즘이지만, 실제 어플리케이션 로직을 포함하지는 않습니다. 다시말해, 이것은 어플리케이션에 명령을 보내는 두가지 방법일 뿐입니다.

Console 디렉토리는 모든 아티즌 명령어들을 포함하고, Http 디렉토리는 컨트롤러와 미들웨어, requests 들을 포함합니다.

Notifications 디렉토리
이 디렉토리는 기본적으로 존재하지 않지만, make:notification 아티즌 명령어를 실행하는 경우 생성됩니다. Notifications 디렉토리는 어플리케이션 안에서 발생하는 이벤트에 대한 간단한 알림으로, 어플리케이션에서 전송되는 "트랜잭션" 알림을 제공합니다.

Rules 디렉토리
이 디렉토리는 기본적으로 존재하지 않습니다만, make:rule 아티즌 명령어를 실행하게 된다면 생성됩니다. Rules 디렉토리는 어플리케이션에서 사용할 수 있는 커스텀 validation-유효성 검사를 위한 객체들을 포함하게 됩니다. Rules 은 복잡한 유효성 검사 로직을 간단한 객체로 캡슐화 하는데 사용됩니다. 보다 자세한 내용은 validation 문서.를 참고하십시오.


----------------------------------


라라벨 어플리케이션의 모든 요청에 대한 시작점은 public/index.php
파일입니다.

웹서버 (Apache / Nginx)의 설정에 따라 모든 요청은 이 파일에 전달됩니다. index.php 파일은 그다지 많은 코드를 가지고 있지 않습니다. 대신 프레임워크의 나머지 부분들을 로딩하기 위한 시작점이 됩니다.

index.php 파일은 컴포저가 생성 한 오토로더 정의를 로딩합니다. 그리고, bootstrap/app.php 스크립트에서 라라벨 어플리케이션의 인스턴스를 가져옵니다. 라라벨 자신의 첫 번째 동작은 서비스 컨테이너 인스턴스를 생성하는 것입니다.

-------------------------

서비스 컨테이너

라라벨의 서비스 컨테이너는 클래스의 의존성을 관리하고 의존성을 주입하는 강력한 도구 입니다.

라라벨 서비스 컨테이너를 깊이 이해하는 것은 강력하고 큰 어플리케이션을 구축 할 때나 라라벨 코어에 공헌하기 위해서 아주 중요한 부분입니다.

--------------------------

서비스 프로바이더

서비스 프로바이더는 라라벨 어플리케이션의 부팅(부트스트래핑)의 가장 핵심이라고 할 수 있습니다. 여러분의 어플리케이션과 마찬가지로 라라벨의 모든 코어 서비스는 서비스 프로바이더를 통해서 부트스트래핑 됩니다.

그런데 "부트스트래핑" 이란 과연 무엇을 의미하는 것일까요? 일반적으로는 서비스 컨테이너에 바인딩을 등록하는 것을 포함해서 이벤트 리스터, 미들웨어 그리고 라우트등을 등록 하는 것을 의미합니다. 서비스 프로바이더는 어플리케이션 구성의 핵심입니다.

---------------------------


MVP Pattern을 알기 전에 Dependency(의존성)에 대해서 한번 알아보고 가자

클래스에서 의존성이란? Dependency란?

    코드에서 두 모듈 간의 연결.

    객체지향언어에서는 두 클래스 간의 관계라고도 말함.

    일반적으로 둘 중 하나가 다른 하나를 어떤 용도를 위해 사용함.

Dependency Injection(의존성 주입)이 필요한 이유

    위 Dependency가 위험한 이유를 해결하기 위해서 사용.

    ‘new’를 사용해 모듈 내에서 다른 모듈을 초기화하지 않으려면 객체 생성은 다른 곳에서 하고, 생성된 객체를 참조하면 된다.

    의존성 주입은 Inversion of Control 개념을 바탕으로 합니다. 클래스가 외부로부터 의존성을 가져야합니다.

    클래스는 다른 클래스를 인스턴스화해야 하지만, 구성 클래스에서 인스턴스를 가져와야 합니다.

클래스 외부에서 종속성을 제공하면 생기는 이점

    클래스를 재사용 할 가능성을 높이고, 다른 클래스와 독립적으로 클래스를 테스트 할  수 있습니다.

    비즈니스 로직의 특정 구현이 아닌 클래스를 생성하는데 매우 효과적

의존성 주입(Dependency Injection)을 어떻게 할 것인가?

    Contructor Injection : 생성자 삽입

    Field Injection : 멤버 변수 삽입( 비공개 안됨)

    Method Injection : 메소드 매게 변수 삽입.


MVC

Route(경로)

Controller (실행,통제)
View (시각적)
Model (DB)

------------------

https://www.slideshare.net/ssusercf5d12/laravel-1?next_slideshow=1

라라벨로 배우는 서버사이드

-----------------------

클로저란?

컴퓨터 언어에서 클로저(Closure)는 일급 객체 함수(first-class functions)의 개념을 이용하여 스코프(scope)에 묶인 변수를 바인딩 하기 위한 일종의 기술이다. 기능상으로, 클로저는 함수를 저장한 레코드(record)이며, 스코프(scope)의 인수(Factor)들은 클로저가 만들어질 때 정의(define)되며, 스코프 내의 영역이 소멸(remove)되었어도 그에 대한 접근(access)은 독립된 복사본인 클로저를 통해 이루어질 수 있다.


익명함수는 클로져 또는 콜백이라고도 한다.


------------------------


라이프 사이클

public/index.php -> Kernel (app/Http/Kernel.php) / Provider (config/app.php) / Route
							proviers 로딩

----------------------

라라벨 어플리케이션 구조

기본적인 라라벨 어플리케이션의 구조는 어플리케이션이 크건, 작건 좋은 시작점이 되는것을
의도하고 있습니다. 당연히 어플리케이션을 원하는대로 구성해도 됩니다.
컴포저가 클래스를 오토로딩할 수 있는 한 클래스를
어디에 위치시키는가에 대한 제약사항은 없습니다.


루트 디렉토리

app 디렉토리는 예상하는바와 같이 어플리케이션의 핵심 코드들을 포함하고 있습니다.

bootstrap 폴더는 프레임워크가 부팅하고 오토로딩을 설정하는 몇몇 파일을 가지고 있습니다.

config 디렉토리는 이름에서 알 수 있듯이 어플리케이션의 모든 설정파일을 가지고 있습니다.

database 폴더는 데이터베이스의 마이그레이션과 시드 파일들을 가지고 있습니다.

public 디렉토리는 프론트엔드를 관리하고 assets(image, javascript, CSS, 기타..) 파일들을 가지고 있습니다.

resources 디렉토리는 뷰파일들과 raw assets(LESS, SASS, CoffeeScript) 그리고 “언어” 파일들을 가지고 있습니다.

storage 디렉토리는 컴파일된 블레이드 템플릿, 파일 세션들, 파일 캐시들 그리고 프레임워크에서 생성한 파일들을 포함하고 있습니다.

tests 디렉토리는 자동화된 테스트 파일을 가지고 있습니다.

vendor 디렉토리는 컴포저의 의존성 폴더입니다.

App 디렉토리

App 디렉토리

어플리케이션의 가장 핵심적인 부분은 app 디렉토리에 있습니다.
기본적으로 이 디렉토리의 네임스페이스는 컴포저가 PSR-4 autoloading standard방식으로
오토로딩될 수 있게 설정된 App으로 설정되어 있습니다.
app:name 아티즌 명령어를 통해서 네임스페이스를 변경할 수 있습니다.

---------------------------

블레이드 템플릿 사용법

@include : 페이지를 마스터 템플릿에 포함
@yield : 교체영역
@section ~~~ @stop : 교체영역

템플릿에서는 PHP 데이터에

{{ 변수명 or 함수명 }} 과 같이 접근


----------------------------

Session

로그인 되어있으면 창을 완전히 닫거나 로그아웃 하기 전까지 계속 로그인 되어있는 상태를 유지하는데 쓰인다.

	상태유지를 위해 세션(Session)을 사용!

-----------------------------

데이터베이스 생성 & 사용자 생성

SHOW DATABSES; // 생성된 데이터베이스를 확인

CREATE DATABASE abcd_db // abcd_db 데이터베이스를 생성

CREATE USER 'abcd'@'localhost' IDENTIFIED BY '1234'; 
// abcd@localhost 계정 생성 비밀번호는 1234

GRANT ALL PRIVILEGES ON abcd_db.* TO 'abcd'@'localhost';
// abcd 계정에 abcd_db 사용권한을 지정

FLUSH PRIVILEGES;
권한 적용

쇼랑 유즈(SHOW, USE)

SHOW DATABASES; 데이터베이스 목록 출력
USE abcd_db; 데이터베이스를 사용
SHOW TABLES; 테이블 리스트를 조회
DROP DATABASES db_name; db_name 스키마를 삭제
DROP TABLE db_table; db_table 테이블을 삭제

----------------------------------

SQL (Structured Query Language)

데이터베이스에 명령하기위해 정해진 구조적 언어

DML(Data Manipulation Language)
DDL(Data Definition Language)
DCL(Data Control Language)

----------------------------------

RDBMS와 mongoDB의 비교

table -> collection

row -> document

column -> field

pk -> object id

relation ship -> embedded linking

정확히 일치한다고 할 수 없지만 기본개념을 이해하기위해서

rdbms에 비유한 것입니다.

---------------------------------

mysql 모니터에서 현재 Character-Set 확인하는 방법 2가지

접속후 아래 명령어 입력

1. show variables like ‘c%’;

2. status;

인프런 ES 6 결제함