
라라벨

친절한 설명 , but not detail

https://tutorials.kode-blog.com/laravel-install-and-configure

https://tutorials.kode-blog.com/laravel-hello-world

불친절한 설명 , but detail

https://laravel.kr/docs/5.6/installation

----------------------------------------

Public 디렉토리
라라벨을 설치후에 어플리케이션의 document / web 루트를 public 디렉토리로 설정해야 합니다. 이 디렉토리의 index.php는 어플리케이션의 모든 HTTP 요청에 대해서 프론트 컨트롤러로 작동합니다.

설정 파일
라라벨 프레임워크의 모든 설정 파일들은 config 디렉토리에 위치합니다. 각각의 옵션들은 문서가 작성되어 있으며, 사용 가능한 옵션들을 이해하기 위해서 전체 문서들을 둘러보는 것이 좋습니다.

디렉토리 권한 설정
라라벨을 설치한 뒤에, 몇몇 권한을 설정해야될 필요가 있습니다. storage 와 bootstrap/cache 디렉토리 안에 들어 있는 디렉토리들은 모두 웹 서버에 의해서 쓰기가 가능해야 합니다. 그렇지 않으면 라라벨이 실행되지 않습니다. 홈스테드를 사용중이라면 이미 권한이 설정되어 있을 것입니다.

어플리케이션 키 설정
라라벨 설치 후 해야할 일은 여러분의 어플리케이션 키를 랜덤한 문자열로 세팅하는 것입니다. 만약 라라벨이 Composer 를 통해서 설치되었다면 키는 php artisan key:generate 명령어가 실행되어 이미 설정되어 있을 것입니다.

일반적으로, 이 키는 32자리의 문자열입니다. 이 키는 .env 환경설정 파일에서 세팅할 수 있습니다. 아직 .env.example 파일을 .env 로 변경하지 않았다면 지금 변경합니다. 만약 어플리케이션 키가 세팅되어있지 않다면, 여러분의 사용자 세션과 그밖의 암호화된 데이터들이 안전하지 않습니다!

추가적인 설정
라라벨은 앞의 내용 이외의 다른 세팅은 거의 필요 하지 않습니다. 이제 편하게 개발을 시작하면 됩니다! 그러나 가급적 config/app.php 파일의 내용을 살펴보길 권장합니다. timezone과 locale과 같이 여러분의 어플리케이션을 따라 바꾸기를 원하는 몇가지 옵션들을 포함하고 있습니다.

다음과 같은 라라벨의 컴포넌트들에 대한 몇가지 설정들을 해둘 수도 있습니다.

Cache -  https://laravel.kr/docs/5.6/cache#configuration
Database - https://laravel.kr/docs/5.6/database#configuration
Session  - https://laravel.kr/docs/5.6/session#configuration

------------------------------------------------

설정 캐시
어플리케이션의 구동 속도를 더 빠르게 하려면, config:cache 아티즌 명령어를 통해서 설정 파일들을 하나로 묶어 캐싱해야 합니다. 이 명령어는 모든 설정 옵션을 하나의 파일로 묶어 어플리케이션이 빠르게 로드할 수 있게 해줍니다.

일반적으로 php artisan config:cache 명령어를 어플리케이션 배포 루틴의 일부에서 실행하도록 해야 합니다. 어플리케이션 개발 중에는 설정 옵션값이 자주 바뀔 필요가 있기 때문에, 로컬 개발 환경에서는 이 명령어를 실행하지 말아야 합니다.

{note} 배포가 진행 되는 도중에 config:cache 명령어를 실행한다면, 설정 파일안에서 env 함수만 호출된다는 것을 확인해야 합니다. 한번, 설정이 캐싱되고 나면, .env 파일은 로딩되지 않고, 모든 env 함수는 null을 반환합니다.

* 로컬 개발 환경에서는 이 명령어를 실행하지 않는다.

--------------------------------

점검모드

cmd창에서 php artisan down -> 점검 모드

php artisan up -> 점검 모드 해제

{tip} resources/views/errors/503.blade.php 파일을 정의해서 점검모드의 응답페이지 템플릿을 커스터마이징 할 수 있습니다.

------------------------------

모델 디렉토리는 어디에 있나요?
라라벨을 시작할 때, 많은 개발자들이 models 디렉토리가 없는 것에 혼란을 느낍니다. 하지만 이 디렉토리가 없는 것은 의도된 것입니다. 우리는 "모델"이라는 많은 사람들에게 각기 다른 의미로 받아들려지기 때문에 모호하다는 것을 알게되었습니다. 일부 개발자들은 어플리케이션의 "모델"을 비지니스 로직의 전체로서 참조하는 반면, 다른 개발자들은 "모델"을 관계형 데이터베이스와 상호작용하는데 사용합니다.

이러한 이유로, 기본적으로 app 디렉토리를 Eloquent 모델이 저장되는 곳으로 선택했으며, 개발자가 원하는 그 어떤 곳이라도 이 파일들을 배치할 수 있게 허용 하고 있습니다.

root 디렉토리 관련

Public 디렉토리
public 디렉토리는 어플리케이션에 진입하는 모든 request-요청들에 대한 진입점 역할과 오토로딩을 설정하는 index.php 파일을 가지고 있습니다. 이 디렉토리는 이미지나 자바스크립트, CSS와 같은 asset파일들을도 포함되어 있습니다.

Bootstrap 디렉토리
bootstrap 디렉토리는 프레임워크의 부트스트래핑을 담당하는 app.php 파일을 가지고 있습니다. 또한 프레임워크가 라우트나 서비스 캐시 파일과 같은 퍼포먼스 향상을 위해서 생성하는 cache 디렉토리를 가지고 있습니다.

---------------------------------

App 디렉토리 관련

app 디렉토리는 Console, Http 그리고 Providers 와 같은 다양한 추가 디렉토리를 가지고 있습니다. Console 과 Http 디렉토리는 어플리케이션의 코어에 API를 제공하고 있다고 생각할 수 있습니다.

HTTP 프로토콜과 CLI 모두 어플리케이션과 상호작용하는 매커니즘이지만, 실제 어플리케이션 로직을 포함하지는 않습니다. 다시말해, 이것은 어플리케이션에 명령을 보내는 두가지 방법일 뿐입니다.

Console 디렉토리는 모든 아티즌 명령어들을 포함하고, Http 디렉토리는 컨트롤러와 미들웨어, requests 들을 포함합니다.

Notifications 디렉토리
이 디렉토리는 기본적으로 존재하지 않지만, make:notification 아티즌 명령어를 실행하는 경우 생성됩니다. Notifications 디렉토리는 어플리케이션 안에서 발생하는 이벤트에 대한 간단한 알림으로, 어플리케이션에서 전송되는 "트랜잭션" 알림을 제공합니다.

Rules 디렉토리
이 디렉토리는 기본적으로 존재하지 않습니다만, make:rule 아티즌 명령어를 실행하게 된다면 생성됩니다. Rules 디렉토리는 어플리케이션에서 사용할 수 있는 커스텀 validation-유효성 검사를 위한 객체들을 포함하게 됩니다. Rules 은 복잡한 유효성 검사 로직을 간단한 객체로 캡슐화 하는데 사용됩니다. 보다 자세한 내용은 validation 문서.를 참고하십시오.


----------------------------------


라라벨 어플리케이션의 모든 요청에 대한 시작점은 public/index.php
파일입니다.

웹서버 (Apache / Nginx)의 설정에 따라 모든 요청은 이 파일에 전달됩니다. index.php 파일은 그다지 많은 코드를 가지고 있지 않습니다. 대신 프레임워크의 나머지 부분들을 로딩하기 위한 시작점이 됩니다.

index.php 파일은 컴포저가 생성 한 오토로더 정의를 로딩합니다. 그리고, bootstrap/app.php 스크립트에서 라라벨 어플리케이션의 인스턴스를 가져옵니다. 라라벨 자신의 첫 번째 동작은 서비스 컨테이너 인스턴스를 생성하는 것입니다.

-------------------------

서비스 컨테이너

라라벨의 서비스 컨테이너는 클래스의 의존성을 관리하고 의존성을 주입하는 강력한 도구 입니다.

라라벨 서비스 컨테이너를 깊이 이해하는 것은 강력하고 큰 어플리케이션을 구축 할 때나 라라벨 코어에 공헌하기 위해서 아주 중요한 부분입니다.

--------------------------

서비스 프로바이더

서비스 프로바이더는 라라벨 어플리케이션의 부팅(부트스트래핑)의 가장 핵심이라고 할 수 있습니다. 여러분의 어플리케이션과 마찬가지로 라라벨의 모든 코어 서비스는 서비스 프로바이더를 통해서 부트스트래핑 됩니다.

그런데 "부트스트래핑" 이란 과연 무엇을 의미하는 것일까요? 일반적으로는 서비스 컨테이너에 바인딩을 등록하는 것을 포함해서 이벤트 리스터, 미들웨어 그리고 라우트등을 등록 하는 것을 의미합니다. 서비스 프로바이더는 어플리케이션 구성의 핵심입니다.

---------------------------


MVP Pattern을 알기 전에 Dependency(의존성)에 대해서 한번 알아보고 가자

클래스에서 의존성이란? Dependency란?

    코드에서 두 모듈 간의 연결.

    객체지향언어에서는 두 클래스 간의 관계라고도 말함.

    일반적으로 둘 중 하나가 다른 하나를 어떤 용도를 위해 사용함.

Dependency Injection(의존성 주입)이 필요한 이유

    위 Dependency가 위험한 이유를 해결하기 위해서 사용.

    ‘new’를 사용해 모듈 내에서 다른 모듈을 초기화하지 않으려면 객체 생성은 다른 곳에서 하고, 생성된 객체를 참조하면 된다.

    의존성 주입은 Inversion of Control 개념을 바탕으로 합니다. 클래스가 외부로부터 의존성을 가져야합니다.

    클래스는 다른 클래스를 인스턴스화해야 하지만, 구성 클래스에서 인스턴스를 가져와야 합니다.

클래스 외부에서 종속성을 제공하면 생기는 이점

    클래스를 재사용 할 가능성을 높이고, 다른 클래스와 독립적으로 클래스를 테스트 할  수 있습니다.

    비즈니스 로직의 특정 구현이 아닌 클래스를 생성하는데 매우 효과적

의존성 주입(Dependency Injection)을 어떻게 할 것인가?

    Contructor Injection : 생성자 삽입

    Field Injection : 멤버 변수 삽입( 비공개 안됨)

    Method Injection : 메소드 매게 변수 삽입.


MVC

Route(경로)

Controller (실행,통제)
View (시각적)
Model (DB)

------------------

https://www.slideshare.net/ssusercf5d12/laravel-1?next_slideshow=1

라라벨로 배우는 서버사이드

-----------------------

클로저란?

컴퓨터 언어에서 클로저(Closure)는 일급 객체 함수(first-class functions)의 개념을 이용하여 스코프(scope)에 묶인 변수를 바인딩 하기 위한 일종의 기술이다. 기능상으로, 클로저는 함수를 저장한 레코드(record)이며, 스코프(scope)의 인수(Factor)들은 클로저가 만들어질 때 정의(define)되며, 스코프 내의 영역이 소멸(remove)되었어도 그에 대한 접근(access)은 독립된 복사본인 클로저를 통해 이루어질 수 있다.


익명함수는 클로져 또는 콜백이라고도 한다.


------------------------


라이프 사이클

public/index.php -> Kernel (app/Http/Kernel.php) / Provider (config/app.php) / Route
							proviers 로딩

----------------------

라라벨 어플리케이션 구조

기본적인 라라벨 어플리케이션의 구조는 어플리케이션이 크건, 작건 좋은 시작점이 되는것을
의도하고 있습니다. 당연히 어플리케이션을 원하는대로 구성해도 됩니다.
컴포저가 클래스를 오토로딩할 수 있는 한 클래스를
어디에 위치시키는가에 대한 제약사항은 없습니다.


루트 디렉토리

app 디렉토리는 예상하는바와 같이 어플리케이션의 핵심 코드들을 포함하고 있습니다.

bootstrap 폴더는 프레임워크가 부팅하고 오토로딩을 설정하는 몇몇 파일을 가지고 있습니다.

config 디렉토리는 이름에서 알 수 있듯이 어플리케이션의 모든 설정파일을 가지고 있습니다.

database 폴더는 데이터베이스의 마이그레이션과 시드 파일들을 가지고 있습니다.

public 디렉토리는 프론트엔드를 관리하고 assets(image, javascript, CSS, 기타..) 파일들을 가지고 있습니다.

resources 디렉토리는 뷰파일들과 raw assets(LESS, SASS, CoffeeScript) 그리고 “언어” 파일들을 가지고 있습니다.

storage 디렉토리는 컴파일된 블레이드 템플릿, 파일 세션들, 파일 캐시들 그리고 프레임워크에서 생성한 파일들을 포함하고 있습니다.

tests 디렉토리는 자동화된 테스트 파일을 가지고 있습니다.

vendor 디렉토리는 컴포저의 의존성 폴더입니다.

App 디렉토리

App 디렉토리

어플리케이션의 가장 핵심적인 부분은 app 디렉토리에 있습니다.
기본적으로 이 디렉토리의 네임스페이스는 컴포저가 PSR-4 autoloading standard방식으로
오토로딩될 수 있게 설정된 App으로 설정되어 있습니다.
app:name 아티즌 명령어를 통해서 네임스페이스를 변경할 수 있습니다.

---------------------------

블레이드 템플릿 사용법

@include : 페이지를 마스터 템플릿에 포함
@yield : 교체영역
@section ~~~ @stop : 교체영역

템플릿에서는 PHP 데이터에

{{ 변수명 or 함수명 }} 과 같이 접근


----------------------------

Session

로그인 되어있으면 창을 완전히 닫거나 로그아웃 하기 전까지 계속 로그인 되어있는 상태를 유지하는데 쓰인다.

	상태유지를 위해 세션(Session)을 사용!

-----------------------------

데이터베이스 생성 & 사용자 생성

SHOW DATABSES; // 생성된 데이터베이스를 확인

CREATE DATABASE abcd_db // abcd_db 데이터베이스를 생성

CREATE USER 'abcd'@'localhost' IDENTIFIED BY '1234'; 
// abcd@localhost 계정 생성 비밀번호는 1234

GRANT ALL PRIVILEGES ON abcd_db.* TO 'abcd'@'localhost';
// abcd 계정에 abcd_db 사용권한을 지정

FLUSH PRIVILEGES;
권한 적용

쇼랑 유즈(SHOW, USE)

SHOW DATABASES; 데이터베이스 목록 출력
USE abcd_db; 데이터베이스를 사용
SHOW TABLES; 테이블 리스트를 조회
DROP DATABASES db_name; db_name 스키마를 삭제
DROP TABLE db_table; db_table 테이블을 삭제

----------------------------------

SQL (Structured Query Language)

데이터베이스에 명령하기위해 정해진 구조적 언어

DML(Data Manipulation Language)
DDL(Data Definition Language)
DCL(Data Control Language)

----------------------------------

RDBMS와 mongoDB의 비교

table -> collection

row -> document

column -> field

pk -> object id

relation ship -> embedded linking

정확히 일치한다고 할 수 없지만 기본개념을 이해하기위해서

rdbms에 비유한 것입니다.

---------------------------------

mysql 모니터에서 현재 Character-Set 확인하는 방법 2가지

접속후 아래 명령어 입력

1. show variables like ‘c%’;

2. status;

--------------------

인프런 ES 6 결제함 -> 이벤트 공짜 JAVASCRIPT 배우기

    slideshare Laravel 로 배우는 서버사이드 #5 
    모델생성할차례임 27쪽!
    
-------------------

Illuminate\Http\Request 인스턴스는 어플리케이션의 HTTP request를 검사할 수 있는 다양한 메소드를 제공합니다. 라라벨의 Illuminate\Http\Request는 Symfony\Component\HttpFoundation\Request 클래스를 상속합니다. 

--------------------------

라라벨에서 POST 전달에 사용되는 토큰은 Post form 에 히든으로 위치해야한다.
없으면 서버전송시 에러가 발생한다.

    <input type="hidden" name="_token" value="{{ csrf_token() }} ">
    
--------------------------

요청 Url에 따라 적절한 패스로 연결시켜주는 것이 바로 Routing의 역할이다.

view는 Helper Function이다. return View::make('welcome')과 같이 라라벨이 제공하는 Facade(파사드 또는 빠사드 라고 읽는다)
를 이용할 수도 있다.
집필자는 보통 view()-> 까지 입력했을 때 코드힌트가 나와서 Helper Function을 더 선호한다.

-----------------------------

블레이드 템플릿 맛보기

{{}} 은 라라벨의 템플릿 엔진인 블레이드에서 사용하는 String Interpolation 문법이다.
즉, 뷰 안에서 <?= ?> 과 같은 역할을 해 주는 것이다. (echo도?)

    참고 : HTML 스트링등 특수문자가 포함된 데이터를 뷰에 바인딩 시킬 때는 {{ }}대신 {!! !!}를 사용한다. {{ $name or '' }} 을 php 문법으로
            컴파일 하면, 대략 echo $name ? $name : ''; 와 같다.
            
------------------------------

엘로퀀트 ORM

엘로퀀트는 라라벨의 ORM (Object Relational Mapper, Active Record Pattern 의 구현체)이다. 데이터베이스는 테이블간 관계를 가지고 있다.
데이터베이스를 추상화한 모델 클래스 간에 관계를 맺어 주는 구현체를 일반적으로 ORM이라 칭한다. 뿐만 아니라 라라벨에서는 config/database.php에
의해 설정된 DB Driver와 ORM 사용으로 인해 데이터베이스와 어플리케이션 간에 디커플링 효과(탈 동조화)도 얻게 된다.
어플리케이션 코드 수정 한 줄 없이 mySQL을 SQLite로 바꿀 수 있다는 의미이다.

엘로퀀트 ORM의 꽃은 모델간의 관계 맺기

------------------------------

참고 사항

테이블 이름을 users 와 같이 복수로, 모델 이름은 User 처럼 단수로 하는 것이 규칙이다. DB 테이블은 Collection을 담고 있고, 모델은 DB 테이블에 담긴 하나의 레코드를 클래스로 표현한 것이기 때문이다. 규칙을 지킬 수 없는 경우에는, 가령 모델명을 Author, 테이블을 users 라 했을 경우, 라라벨이 둘 간의 관계를 알 수 있도록 Author 모델에 protected $table = 'users'; 코드를 추가해 주어야 한다.

쿼리를 배우기 위해 라라벨에서 제공하는 REPL 을 이용하자. tinker('어설프게 손보고 고치다' 라는 뜻)라고 불리는 artisan 커맨드인데, 라라벨의 모든 환경이 제공되기 때문에 여러가지 실험적인 시도들을 해보기 편리하다. ( DB 쿼리, 쿼리 빌더, 엘로퀀트 ORM도 연습 가능 ) 

-------------------------------

 쿼리 빌더 에서 사용할 수 있는 대부분의 메소드는 Eloquent Model에서도 사용할 수 있다. 
 예를 들면, App\Author::orderBy('id', 'desc')->limit(1)->lists('email');와 같이. 
 사실, 이번 강좌에서 보는 것은 엘로퀀트를 상속한 모델을 이용해서 쿼리 빌더를 쓸 수 있다는 정도이다. 
 엘로퀀트의 전부가 아니란 얘기다. 엘로퀀트 ORM의 꽃은 모델간의 관계 맺기이다.
 
 --------------------------------
 
    엘로퀀트는 모든 모델이 updated_at과 created_at 필드가 있다고 가정하고, 
    새로운 Instance가 생성될 때 현재의 timestamp값을 입력하려한다. 그런데, 수작업으로 만든 테이블들은 앞서 말한 
     필드들이 존재하지 않는다. 방법은 필드를 추가하는 방법과, timestamp 입력을 모델에서 끄는 방법이 있는데, 실습을 위해서 일단 꺼뒀음.
    // public $timestamps = false; 사
    
 모델에 변경이 생기면 실행중이던 tinker 를 다시 실행해 주어야 한다. tinker 가 로드될 시점에 라라벨 구동을 위한 모든 환경이 로드되므로, 이후 변경을 반영하기 위함이다. ctrl + C 또는 >>> exit 명령으로 종료할 수 있다.
 
 --------------------------------
 
 bcrypt(string $value) 은 암호화된 60byte스트링를 만들어 준다. Facade로 쓰면 Hash::make(string $value) 와 같다.
 
 암호화해주는 헬퍼 기능 함수임.
 
 -----------------------------
 
 라라벨의 구현한 객체 관계 맵퍼(ORM)인 엘로퀀트가 하는 역할입니다. 데이터베이스의 컬럼을 읽어와서 객체의 속성 값으로 채우거나, 반대로 객체의 속성을 데이터베이스 컬럼에 쓰는 역할을 합니다. 모델과 테이블 이름이 관례를 따를 때는 (모델:User, 테이블:users) 특별한 설정이 필요없으며, 다를 때는 모델:Author, 테이블:users 일때, Author 클래스에 public $tables = 'users'; 엘로퀀트에게 테이블 이름을 알려 주면 됩니다.
 
 --------------------------------
 
DB 마이그레이션

    마이그레이션은 데이터베이스를 위한 버전 컨트롤이라 생각하면 된다. 처음 테이블을 생성하고, 가령 이후에 새로운 필드를 추가한다든지, 필드의 이름을 바꾼다든지 등의 이력을 모두 마이그레이션 코드로 남겨 두고, 테이블을 생성했다가 롤백하는 등 자유롭게 이용할 수 있다.
    
    
    p.s
    
    대형 서비스라면 테이블 스키마를 변경해야 할 수도 있는 새로운 요구사항이 생길 수 있다. 이때 기초공사를 잘못해 두었다면, 개발자에게 엄청난 위기 상황이 닥칠 수도 있는데, 마이그레이션이 위기에서 개발자를 구해주는 데 도움을 줄 것이다. 정말로~ 그리고, 팀으로 여러 명이 테이블 스키마를 변경해 가면서 개발할 때는, mysqldump 해서 주고 받는 수고를 피하기 위해 꼭 필요하다.

사용자 추가 및 권한 추가 및 사용자 계정 삭제

https://cjh5414.github.io/mysql-create-user/

-----------------------------------

migration Reset & Refresh

migrate:rollback 이 직전 마이그레이션만 롤백하는 반면 migrate:reset 는 모든 마이그레이션을 롤백하고 데이터베이스를 초기화 시킨다. migrate:refresh 는 리셋을 실행해서 데이터베이스를 청소한 후, 마이그레이션을 처음부터 다시 실행하는 코맨드이다.

---------------------------------------

MVC 모델 뷰 컨트롤러

그중 C(컨트롤러)에 대해 살펴보자

컨트롤러가 필요한 이유

Route에 모든 비즈니스 로직을 넣을 수 없을 뿐더러, 코드를 효율적으로 구조화시키기 위해서 컨트롤러를 사용하여 구조화한 것이라 생각하면 된다.

--------------------------------

블레이드는 라라벨의 템플릿 엔진이다. 뷰 안에 포함된 블레이드 문법들은 블레이드 엔진에 의해 php 코드로 컴파일 된다.

{{}} - String interpolation 
    php echo 코멘트와 같은 역할을 해준다.  
    
{{-- --}} - Comment

    HTML 주석으로 컴파일 된다. 그런데 브라우저에서 소스보기로 보면 엄연히 다르다.
    
@foreach, @if, @forelse
    
@yield, @extends, @section - 마스터 레이아웃 사용하기

    @extends라는 키워드는 index.blade.php가 master.blade.php를 상속한다는 뜻이다. 또 @yield('content') 와 @section('content')를 주목하자. content라고 이름 지어진 섹션이 마스터 레이아웃에서 yield('양도하다', '넘겨주다' 라는 뜻) 된다는 의미다. 섹션은 원하는 숫자만큼 여러개 만들 수 있다. 뷰에서 만든 섹션의 이름으로 마스터 레이아웃에서 yield해 주기만 하면 된다. 

@include - 하위 뷰 포함하기

------------------------------------

라라벨은 CSRF(Cross Site Request Forgery) 공격을 방지하기 위해 기존 데이터를 변경하는 행위, 즉, 신규 생성, 업데이트, 삭제 등의 행위에 대해서는 CSRF 토큰을 폼요청에서 제공해야 한다. 가령 PostsController@create 메소드에서 응답한 모델 생성 폼에서 숨은 필드로 _token 값을 제공해야 한다. 폼 요청을 받은 PostsController@store 메소드는 토큰의 유효성을 확인하고, 같은 세션일 경우, 즉, create()를 요청한 클라이언트와 store()를 요청한 클라이언트가 동일할 경우에만 store() 액션을 수행한다. 
PostMan을 통해서 테스트하는 행위 자체가 CSRF 공격이라 볼 수 있다.

보안
HTTP 메소드를 사용할 때, 보안 측면을 고려하십시오. 더 강력한 보안을 위해, 일부 방화벽은 HTTP PUT 또는 DELETE 트래픽을 허용하지 않습니다.

-------------------------------------

중복된 Route의 경우, 항상 위에 정의된 것이 아래에 정의된 것을 오버라이드 한다. 가령 posts/count 라는 Route가 있다면 RESTful Resource 정의보다 먼저(== 위에) 정의하는게 안전하다.

--------------------------------------

"서로 다른 시스템간에 네트워크를 경유해서 데이터를 교환할 때 HTTP API 라는 것을 이용하는데, 아무렇게나 짜는 게 아니라, 기계 뿐 아니라 사람이 이해하기 쉽도록, 모두가 사용하고 권장하는 형태인 REST 원칙을 따르도록 짠 API" 가 "RESTful API" 인 것이다.

-------------------------------

중첩된 리소스
특정 리소스에 딸린 하위 리소스를 보여줘야 하는 경우가 있다. 가령, Post id 1번에 딸린 Comment 목록을 보여주거나, Comment를 생성/수정/삭제하는 경우 등이다.

리소스 컨트롤러 만들기

ex ) php artisan make:controller PostCommentController --resource

----------------------------------

http://haah.kr/2017/06/12/rest-the-big-lie/

나중에 실력 쌓이면 꼭 봐야할 사이트

------------------------------------

사용자 인증 기본기

좀 과장해서, 어떤 프로젝트든 로그인이 거의 업무량의 절반이라고들 한다. 그만큼 User 모델과 연결된 기능들이 많다는 의미로 이해하면 되겠다. 서비스에 들어온 사용자를 식별하는 방법을 인증(Authentication)이라 한다. 바꾸어 말하면, 사용자가 제시한 신분증이 DB에 저장된 User 정보와 동일한지 확인하고, 맞으면 통과시켜 주면서, 세션이라는 명찰을 하나 나눠 주는 행위라 이해할 수 있다.

    User 모델

        라라벨에는 User 모델과 마이그레이션이 이미 포함되어 있다. 
        app/User.php를 살펴보자.

-------------------------------------

AppServiceProvider.php 파일에 (DB마이그레이션 할 때)

use Illuminate\Support\Facades\Schema; // 이게 있어야 마이그레이션 가능


또한 MariaDB 또는 이전 버전의 MySQL 사용자는

AppServiceProvider.php 파일을 편집하고 수정해줘야 한다.

use Illuminate\Support\Facades\Schema;

public function boot()
{
    Schema::defaultStringLength(191);
}

https://laravel-news.com/laravel-5-4-key-too-long-error

------------------------------

로그인 뷰에서 소스보기를 해 보자. <input type="hidden" name="_token" value="jPR...nO2"> 란 라인을 볼 수 있다. 
바로 csrf_field() Helper Function이 CSRF 공격을 막기 위해 만든 토큰을 담은 숨은 입력 폼이다. 
13강에서 공부한 내용이다. {!! !!}은 '<', '>' 같은 특수문자의 '<', '>' Escaping 되는 것을 막기 위한 블레이드의 Interpolation 문법이다.

----------------------

라라벨에서 기본 제공하는 인증에서 패스워드는 최소 6자리 이상이어야 한다. 
App\Http\Controllers\Auth\RegisterController@validator 메소드를 보면 'password' => 'required|confirmed|min:6' 라고 
유효성 검사 규칙이 지정되어 있는 것을 확인할 수 있다. 유효성 검사, 뷰에 쓰인 old() 함수에 대해서는 뒤에서 다시 살펴보도록 하자.

--------------------

외래키 연결이 있는 관계에서 컬럼을 삭제할 수 없다.

migration 메소드 

	up 은 버젼 업데이트
	down 은 롤백에 사용

----------------

데이터 심기

앞에서 마이그레이션으로 테이블을 만들어 보았다. 만
들어진 테이블에 테스트 데이터 또는 기본 데이터를 심는 과정을 씨딩(Seeding)이라 한다. 
라라벨 5부터 Seeding을 효율적으로 하기 위한 Factory 기능이 제공된다. 
Factory는 데이터베이스 Seeding 뿐만 아니라, 테스트 클래스에서 필요한 데이터를 Stubbing하는데도 유용하게 사용할 수 있다.

factory() Helper 에서 호출한 make() 메소드는 메모리에 모델 인스턴스만 생성하는 반면, 곧 보게 될 create() 메소드는 모델 인스턴스를 생성하고 DB에 저장하는 일까지 한다.

factory() Helper Function을 이용해서 Seeder 클래스를 채우자. truncate() 메소드는 모델과 연결된 테이블 데이터를 깨끗이 지워주는 역할을 해 준다.

ex) // database/seeds/UsersTableSeeder
class UsersTableSeeder extends Seeder 
{
    public function run() 
    {
        App\User::truncate();
        factory('App\User', 10)->create();
    }
}

Seeder 클래스가 완성되었으면 마스터 Seeder 클래스인, database/seeds/DatabaseSeeder.php 에 등록하자. 
Model::ungard()는 모든 모델에 대해 MassAssignment를 허용한다는 의미이다.

-------------------

기본적으로 블레이드 {{ }} 문장은 XSS 공격을 방지하기 위해 PHP의 htmlspecialchars 함수를 통과합니다. 데이터를 escape 처리를 하지 않으려면 다음과 같이 작성하면 됩니다:

Hello, {!! $name !!}.

어플리케이션의 사용자들로 부터 입력하여 표시되는 컨텐츠를 출력할 때는 
escape-이스케이프에 대한 주의가 필요합니다. 
사용자가 제공한 데이터를 표시 할 때 XSS 공격을 방지하려면 항상 이스케이프 처리 된 이중 중괄호 문법을 사용하십시오.

------------------

eager loading
eager 로딩, 이거 로딩, 사전예약 로딩, 사전 로딩, 선행 로딩, 즉시 로딩
로딩시 참조해야 하는 정보를 미리 명시하는 일
N+1 쿼리 문제의 해결을 통해 성능 향상
ORM 활용시 흔히 발생할 수 있는 N+1 문제 해결 가능
게으른 로딩의 반대개념

Eager 로딩. 쿼리 갯수를 N+1에서 2개로 줄인다.
ORM 활용시 흔히 발생할 수 있는 N+1 문제 해결 가능

with(string|array $relations) 메소드는 항상 엘로퀀트 모델 바로 뒤, 다른 메소드를 체인하기 전에 써야 한다. 
메소드의 인자는 테이블 이름이 아니라, 모델 클래스에서 정의한 관계를 나타내는 메소드 이름임을 잘 기억하자.

ex)  Eager 로딩
Route::get('posts', function() {
    $posts = App\Post::with('user')->get();

    return view('posts.index', compact('posts'));
});

user 정보가 없어서 건수만큼 쿼리 추가 수행 (1+N회)
user 정보를 사용하겠다고 미리 알려줌으로써 쿼리 최소화 (2회)

Lazy Eager 로딩

가끔 엘로퀀트를 이용한 쿼리를 먼저 만들어 놓고, 나중에 관계를 로드해야 하는 경우가 발생할 수 있다. 
이때는 load(string|array $relations) 메소드를 이용할 수 있다.
(예를 들면, 쿼리 하나를 여러 번 재사용할 경우, 앞에서는 Eager 로딩이 필요없었지만, 나중에 필요하게 되는 경우 등이 해당된다. )

ex) 
Route::get('posts', function() {
    $posts = App\Post::get();
    $posts->load('user');

    return view('posts.index', compact('posts'));
});

-----------------------------

페이징

모델에 데이터가 많아지면 한번에 모든 레코드를 표시할 수가 없게 된다. 이때 필요한 것이 페이징이다.

app/Http/routes.php 에 아래와 같이 Route를 써 보자. 
모델에 대한 쿼리 끝에 get() 이나 find() 대신, paginate() 메소드를 체인하면 페이징을 위한 준비 완료! 
인자는 한번에 반환할 Collection 갯수를 넣는다. 이 예제에서는 10개로 했다.

Route::get('posts', function() {
    $posts = App\Post::with('user')->paginate(10);

    return view('posts.index', compact('posts'));
});

라라벨 페이징은 twitter bootstrap과 완벽하게 호환된다. 확인을 위해 resources/views/master.blade.php 에 bootstrap 사용을 선언하자.

20강에서 사용하던 resources/views/posts/index.blade.php 를 그대로 사용하자. 
@stop 바로 전에 아래 코드를 추가하자. paginate() 메소드를 체임함으로써, 
$posts 객체는 페이징이 가능한 Paginator 인스턴스로 변경되었고 render() 메소드를 쓸 수 있게 된 것이다. 
렌더링된 뷰에서 소스보기를 해서 어떤 코드가 추가되었는 지 확인해 보자.

@if($posts)
    <div class="text-center">
      {!! $posts->render() !!}
    </div>
  @endif
@stop

이 코드를 추가하고, 브라우저 소스보기와 비교해본다.
(직접 짜면 몹시 복잡한 페이지네이션 코드를 간단한 코드로 생성하였다.)

---------------

메일보내기

메일건 회원가입

.env 에서 MAIL로 시작하는 설정 전부 지우기
MAIL_DRIVER=smtp
MAIL_HOST=smtp.mailtrap.io
MAIL_PORT=2525
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null

메일을 보내 보자.
app/Http/routes.php 에 메일을 보내는 Route를 작성하자. 노파심에 다시 얘기하면, 학습을 위해 편의상 routes.php 에 작성하지만, 실전에서는 컨트롤러 (또는 서비스 로직)에 들어가야 하는 내용이다.

Route::get('mail', function() {
    $to = 'YOUR@EMAIL.ADDRESS';
    $subject = 'Studying sending email in Laravel';
    $data = [
        'title' => 'Hi there',
        'body'  => 'This is the body of an email message',
        'user'  => App\User::find(1)
    ];

    return Mail::send('emails.welcome', $data, function($message) use($to, $subject) {
        $message->to($to)->subject($subject);
    });
});
send() 메소는 3개의 인자를 받는다. 첫번째는 사용할 뷰, 두번 째는 뷰에서 바인딩 시킬 데이터, 세번째는 콜백이다.

참고 send() 대신 queue() 메소드를 사용하는 것이 편리하다. Queue 설정이 되어 있지 않으면, send()로 자동 폴백된다.