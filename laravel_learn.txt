
라라벨

친절한 설명 , but not detail

https://tutorials.kode-blog.com/laravel-install-and-configure

https://tutorials.kode-blog.com/laravel-hello-world

불친절한 설명 , but detail

https://laravel.kr/docs/5.6/installation

---------------------------

프레임워크란?


1. 프레임워크(Framework)

	프레임워크는 어떠한 목적을 달성하기 위해 복잡하게 얽혀있는 문제를 해결하기 위한 구조이며, 소프트웨어 개발에 있어 하나의 뼈대를 한다.

2. 라이브러리와의 차이점

	보통 프레임워크라고 하면 클래스와 라이브러리가 합쳐진 형태라고 볼 수 있다.

	메소드 및 클래스화, 즉 모듈화를 하는 이유 중 하나가 재사용성인데, 
    프레임워크는 이 재사용성을 큰 그룹 단위로 묶어주었다고 보면 된다. 
    재사용 가능한 수많은 클래스들과 라이브러리들을 융합한채로 처음부터 제공해 주기 때문에, 여러 개의 표준을 만들지 않아도 돼서 개발자들의 피곤함을 덜어준다.

----------------------------------------

Public 디렉토리
라라벨을 설치후에 어플리케이션의 document / web 루트를 public 디렉토리로 설정해야 합니다. 이 디렉토리의 index.php는 어플리케이션의 모든 HTTP 요청에 대해서 프론트 컨트롤러로 작동합니다.

설정 파일
라라벨 프레임워크의 모든 설정 파일들은 config 디렉토리에 위치합니다. 각각의 옵션들은 문서가 작성되어 있으며, 사용 가능한 옵션들을 이해하기 위해서 전체 문서들을 둘러보는 것이 좋습니다.

디렉토리 권한 설정
라라벨을 설치한 뒤에, 몇몇 권한을 설정해야될 필요가 있습니다. storage 와 bootstrap/cache 디렉토리 안에 들어 있는 디렉토리들은 모두 웹 서버에 의해서 쓰기가 가능해야 합니다. 그렇지 않으면 라라벨이 실행되지 않습니다. 홈스테드를 사용중이라면 이미 권한이 설정되어 있을 것입니다.

어플리케이션 키 설정
라라벨 설치 후 해야할 일은 여러분의 어플리케이션 키를 랜덤한 문자열로 세팅하는 것입니다. 만약 라라벨이 Composer 를 통해서 설치되었다면 키는 php artisan key:generate 명령어가 실행되어 이미 설정되어 있을 것입니다.

일반적으로, 이 키는 32자리의 문자열입니다. 이 키는 .env 환경설정 파일에서 세팅할 수 있습니다. 아직 .env.example 파일을 .env 로 변경하지 않았다면 지금 변경합니다. 만약 어플리케이션 키가 세팅되어있지 않다면, 여러분의 사용자 세션과 그밖의 암호화된 데이터들이 안전하지 않습니다!

추가적인 설정
라라벨은 앞의 내용 이외의 다른 세팅은 거의 필요 하지 않습니다. 이제 편하게 개발을 시작하면 됩니다! 그러나 가급적 config/app.php 파일의 내용을 살펴보길 권장합니다. timezone과 locale과 같이 여러분의 어플리케이션을 따라 바꾸기를 원하는 몇가지 옵션들을 포함하고 있습니다.

다음과 같은 라라벨의 컴포넌트들에 대한 몇가지 설정들을 해둘 수도 있습니다.

Cache -  https://laravel.kr/docs/5.6/cache#configuration
Database - https://laravel.kr/docs/5.6/database#configuration
Session  - https://laravel.kr/docs/5.6/session#configuration

------------------------------------------------

설정 캐시
어플리케이션의 구동 속도를 더 빠르게 하려면, config:cache 아티즌 명령어를 통해서 설정 파일들을 하나로 묶어 캐싱해야 합니다. 이 명령어는 모든 설정 옵션을 하나의 파일로 묶어 어플리케이션이 빠르게 로드할 수 있게 해줍니다.

일반적으로 php artisan config:cache 명령어를 어플리케이션 배포 루틴의 일부에서 실행하도록 해야 합니다. 어플리케이션 개발 중에는 설정 옵션값이 자주 바뀔 필요가 있기 때문에, 로컬 개발 환경에서는 이 명령어를 실행하지 말아야 합니다.

{note} 배포가 진행 되는 도중에 config:cache 명령어를 실행한다면, 설정 파일안에서 env 함수만 호출된다는 것을 확인해야 합니다. 한번, 설정이 캐싱되고 나면, .env 파일은 로딩되지 않고, 모든 env 함수는 null을 반환합니다.

* 로컬 개발 환경에서는 이 명령어를 실행하지 않는다.

--------------------------------

점검모드

cmd창에서 php artisan down -> 점검 모드

php artisan up -> 점검 모드 해제

{tip} resources/views/errors/503.blade.php 파일을 정의해서 점검모드의 응답페이지 템플릿을 커스터마이징 할 수 있습니다.

------------------------------

모델 디렉토리는 어디에 있나요?
라라벨을 시작할 때, 많은 개발자들이 models 디렉토리가 없는 것에 혼란을 느낍니다. 하지만 이 디렉토리가 없는 것은 의도된 것입니다. 우리는 "모델"이라는 많은 사람들에게 각기 다른 의미로 받아들려지기 때문에 모호하다는 것을 알게되었습니다. 일부 개발자들은 어플리케이션의 "모델"을 비지니스 로직의 전체로서 참조하는 반면, 다른 개발자들은 "모델"을 관계형 데이터베이스와 상호작용하는데 사용합니다.

이러한 이유로, 기본적으로 app 디렉토리를 Eloquent 모델이 저장되는 곳으로 선택했으며, 개발자가 원하는 그 어떤 곳이라도 이 파일들을 배치할 수 있게 허용 하고 있습니다.

root 디렉토리 관련

Public 디렉토리
public 디렉토리는 어플리케이션에 진입하는 모든 request-요청들에 대한 진입점 역할과 오토로딩을 설정하는 index.php 파일을 가지고 있습니다. 이 디렉토리는 이미지나 자바스크립트, CSS와 같은 asset파일들을도 포함되어 있습니다.

Bootstrap 디렉토리
bootstrap 디렉토리는 프레임워크의 부트스트래핑을 담당하는 app.php 파일을 가지고 있습니다. 또한 프레임워크가 라우트나 서비스 캐시 파일과 같은 퍼포먼스 향상을 위해서 생성하는 cache 디렉토리를 가지고 있습니다.

---------------------------------

App 디렉토리 관련

app 디렉토리는 Console, Http 그리고 Providers 와 같은 다양한 추가 디렉토리를 가지고 있습니다. Console 과 Http 디렉토리는 어플리케이션의 코어에 API를 제공하고 있다고 생각할 수 있습니다.

HTTP 프로토콜과 CLI 모두 어플리케이션과 상호작용하는 매커니즘이지만, 실제 어플리케이션 로직을 포함하지는 않습니다. 다시말해, 이것은 어플리케이션에 명령을 보내는 두가지 방법일 뿐입니다.

Console 디렉토리는 모든 아티즌 명령어들을 포함하고, Http 디렉토리는 컨트롤러와 미들웨어, requests 들을 포함합니다.

Notifications 디렉토리
이 디렉토리는 기본적으로 존재하지 않지만, make:notification 아티즌 명령어를 실행하는 경우 생성됩니다. Notifications 디렉토리는 어플리케이션 안에서 발생하는 이벤트에 대한 간단한 알림으로, 어플리케이션에서 전송되는 "트랜잭션" 알림을 제공합니다.

Rules 디렉토리
이 디렉토리는 기본적으로 존재하지 않습니다만, make:rule 아티즌 명령어를 실행하게 된다면 생성됩니다. Rules 디렉토리는 어플리케이션에서 사용할 수 있는 커스텀 validation-유효성 검사를 위한 객체들을 포함하게 됩니다. Rules 은 복잡한 유효성 검사 로직을 간단한 객체로 캡슐화 하는데 사용됩니다. 보다 자세한 내용은 validation 문서.를 참고하십시오.


----------------------------------


라라벨 어플리케이션의 모든 요청에 대한 시작점은 public/index.php
파일입니다.

웹서버 (Apache / Nginx)의 설정에 따라 모든 요청은 이 파일에 전달됩니다. index.php 파일은 그다지 많은 코드를 가지고 있지 않습니다. 대신 프레임워크의 나머지 부분들을 로딩하기 위한 시작점이 됩니다.

index.php 파일은 컴포저가 생성 한 오토로더 정의를 로딩합니다. 그리고, bootstrap/app.php 스크립트에서 라라벨 어플리케이션의 인스턴스를 가져옵니다. 라라벨 자신의 첫 번째 동작은 서비스 컨테이너 인스턴스를 생성하는 것입니다.

-------------------------

서비스 컨테이너

라라벨의 서비스 컨테이너는 클래스의 의존성을 관리하고 의존성을 주입하는 강력한 도구 입니다.

라라벨 서비스 컨테이너를 깊이 이해하는 것은 강력하고 큰 어플리케이션을 구축 할 때나 라라벨 코어에 공헌하기 위해서 아주 중요한 부분입니다.

--------------------------

서비스 프로바이더

서비스 프로바이더는 라라벨 어플리케이션의 부팅(부트스트래핑)의 가장 핵심이라고 할 수 있습니다. 여러분의 어플리케이션과 마찬가지로 라라벨의 모든 코어 서비스는 서비스 프로바이더를 통해서 부트스트래핑 됩니다.

그런데 "부트스트래핑" 이란 과연 무엇을 의미하는 것일까요? 일반적으로는 서비스 컨테이너에 바인딩을 등록하는 것을 포함해서 이벤트 리스터, 미들웨어 그리고 라우트등을 등록 하는 것을 의미합니다. 서비스 프로바이더는 어플리케이션 구성의 핵심입니다.

---------------------------


MVP Pattern을 알기 전에 Dependency(의존성)에 대해서 한번 알아보고 가자

클래스에서 의존성이란? Dependency란?

    코드에서 두 모듈 간의 연결.

    객체지향언어에서는 두 클래스 간의 관계라고도 말함.

    일반적으로 둘 중 하나가 다른 하나를 어떤 용도를 위해 사용함.

Dependency Injection(의존성 주입)이 필요한 이유

    위 Dependency가 위험한 이유를 해결하기 위해서 사용.

    ‘new’를 사용해 모듈 내에서 다른 모듈을 초기화하지 않으려면 객체 생성은 다른 곳에서 하고, 생성된 객체를 참조하면 된다.

    의존성 주입은 Inversion of Control 개념을 바탕으로 합니다. 클래스가 외부로부터 의존성을 가져야합니다.

    클래스는 다른 클래스를 인스턴스화해야 하지만, 구성 클래스에서 인스턴스를 가져와야 합니다.

클래스 외부에서 종속성을 제공하면 생기는 이점

    클래스를 재사용 할 가능성을 높이고, 다른 클래스와 독립적으로 클래스를 테스트 할 수 있습니다.

    비즈니스 로직의 특정 구현이 아닌 클래스를 생성하는데 매우 효과적

의존성 주입(Dependency Injection)을 어떻게 할 것인가?

    Contructor Injection : 생성자 삽입

    Field Injection : 멤버 변수 삽입( 비공개 안됨)

    Method Injection : 메소드 매개 변수 삽입.


MVC

Route(경로)

Controller (실행,통제)
View (시각적)
Model (DB)

------------------

https://www.slideshare.net/ssusercf5d12/laravel-1?next_slideshow=1

라라벨로 배우는 서버사이드

-----------------------

클로저란?

컴퓨터 언어에서 클로저(Closure)는 일급 객체 함수(first-class functions)의 개념을 이용하여 스코프(scope)에 묶인 변수를 바인딩 하기 위한 일종의 기술이다. 


기능상으로, 클로저는 함수를 저장한 레코드(record)이며, 스코프(scope)의 인수(Factor)들은 클로저가 만들어질 때 정의(define)되며, 스코프 내의 영역이 소멸(remove)되었어도 그에 대한 접근(access)은 독립된 복사본인 클로저를 통해 이루어질 수 있다.


익명함수는 클로져 또는 콜백이라고도 한다.


------------------------


라이프 사이클

public/index.php -> Kernel (app/Http/Kernel.php) / Provider (config/app.php) / Route
							proviers 로딩

----------------------

라라벨 어플리케이션 구조

기본적인 라라벨 어플리케이션의 구조는 어플리케이션이 크건, 작건 좋은 시작점이 되는것을
의도하고 있습니다. 당연히 어플리케이션을 원하는대로 구성해도 됩니다.
컴포저가 클래스를 오토로딩할 수 있는 한 클래스를
어디에 위치시키는가에 대한 제약사항은 없습니다.


루트 디렉토리

app 디렉토리는 예상하는바와 같이 어플리케이션의 핵심 코드들을 포함하고 있습니다.

bootstrap 폴더는 프레임워크가 부팅하고 오토로딩을 설정하는 몇몇 파일을 가지고 있습니다.

config 디렉토리는 이름에서 알 수 있듯이 어플리케이션의 모든 설정파일을 가지고 있습니다.

database 폴더는 데이터베이스의 마이그레이션과 시드 파일들을 가지고 있습니다.

public 디렉토리는 프론트엔드를 관리하고 assets(image, javascript, CSS, 기타..) 파일들을 가지고 있습니다.

resources 디렉토리는 뷰파일들과 raw assets(LESS, SASS, CoffeeScript) 그리고 “언어” 파일들을 가지고 있습니다.

storage 디렉토리는 컴파일된 블레이드 템플릿, 파일 세션들, 파일 캐시들 그리고 프레임워크에서 생성한 파일들을 포함하고 있습니다.

tests 디렉토리는 자동화된 테스트 파일을 가지고 있습니다.

vendor 디렉토리는 컴포저의 의존성 폴더입니다.

App 디렉토리

App 디렉토리

어플리케이션의 가장 핵심적인 부분은 app 디렉토리에 있습니다.
기본적으로 이 디렉토리의 네임스페이스는 컴포저가 PSR-4 autoloading standard방식으로
오토로딩될 수 있게 설정된 App으로 설정되어 있습니다.
app:name 아티즌 명령어를 통해서 네임스페이스를 변경할 수 있습니다.

---------------------------

블레이드 템플릿 사용법

@include : 페이지를 마스터 템플릿에 포함
@yield : 교체영역
@section ~~~ @stop : 교체영역

템플릿에서는 PHP 데이터에

{{ 변수명 or 함수명 }} 과 같이 접근


----------------------------

Session

로그인 되어있으면 창을 완전히 닫거나 로그아웃 하기 전까지 계속 로그인 되어있는 상태를 유지하는데 쓰인다.

	상태유지를 위해 세션(Session)을 사용!

-----------------------------

데이터베이스 생성 & 사용자 생성

SHOW DATABSES; // 생성된 데이터베이스를 확인

CREATE DATABASE abcd_db // abcd_db 데이터베이스를 생성

CREATE USER 'abcd'@'localhost' IDENTIFIED BY '1234'; 
// abcd@localhost 계정 생성 비밀번호는 1234

GRANT ALL PRIVILEGES ON abcd_db.* TO 'abcd'@'localhost';
// abcd 계정에 abcd_db 사용권한을 지정

FLUSH PRIVILEGES;
권한 적용

쇼랑 유즈(SHOW, USE)

SHOW DATABASES; 데이터베이스 목록 출력
USE abcd_db; 데이터베이스를 사용
SHOW TABLES; 테이블 리스트를 조회
DROP DATABASES db_name; db_name 스키마를 삭제
DROP TABLE db_table; db_table 테이블을 삭제

----------------------------------

SQL (Structured Query Language)

데이터베이스에 명령하기위해 정해진 구조적 언어

DML(Data Manipulation Language)
DDL(Data Definition Language)
DCL(Data Control Language)

----------------------------------

RDBMS와 mongoDB의 비교

table -> collection

row -> document

column -> field

pk -> object id

relation ship -> embedded linking

정확히 일치한다고 할 수 없지만 기본개념을 이해하기위해서

rdbms에 비유한 것입니다.

---------------------------------

mysql 모니터에서 현재 Character-Set 확인하는 방법 2가지

접속후 아래 명령어 입력

1. show variables like ‘c%’;

2. status;

--------------------

인프런 ES 6 결제함 -> 이벤트 공짜 JAVASCRIPT 배우기

    slideshare Laravel 로 배우는 서버사이드 #5 
    모델생성할차례임 27쪽!
    
-------------------

Illuminate\Http\Request 인스턴스는 어플리케이션의 HTTP request를 검사할 수 있는 다양한 메소드를 제공합니다. 라라벨의 Illuminate\Http\Request는 Symfony\Component\HttpFoundation\Request 클래스를 상속합니다. 

--------------------------

라라벨에서 POST 전달에 사용되는 토큰은 Post form 에 히든으로 위치해야한다.
없으면 서버전송시 에러가 발생한다.

    <input type="hidden" name="_token" value="{{ csrf_token() }} ">
    
--------------------------

요청 Url에 따라 적절한 패스로 연결시켜주는 것이 바로 Routing의 역할이다.

view는 Helper Function이다. return View::make('welcome')과 같이 라라벨이 제공하는 Facade(파사드 또는 빠사드 라고 읽는다)
를 이용할 수도 있다.
집필자는 보통 view()-> 까지 입력했을 때 코드힌트가 나와서 Helper Function을 더 선호한다.

-----------------------------

블레이드 템플릿 맛보기

{{}} 은 라라벨의 템플릿 엔진인 블레이드에서 사용하는 String Interpolation 문법이다.
즉, 뷰 안에서 <?= ?> 과 같은 역할을 해 주는 것이다. (echo도?)

    참고 : HTML 스트링등 특수문자가 포함된 데이터를 뷰에 바인딩 시킬 때는 {{ }}대신 {!! !!}를 사용한다. {{ $name or '' }} 을 php 문법으로
            컴파일 하면, 대략 echo $name ? $name : ''; 와 같다.
            
------------------------------

엘로퀀트 ORM

엘로퀀트는 라라벨의 ORM (Object Relational Mapper, Active Record Pattern 의 구현체)이다. 데이터베이스는 테이블간 관계를 가지고 있다.
데이터베이스를 추상화한 모델 클래스 간에 관계를 맺어 주는 구현체를 일반적으로 ORM이라 칭한다. 뿐만 아니라 라라벨에서는 config/database.php에
의해 설정된 DB Driver와 ORM 사용으로 인해 데이터베이스와 어플리케이션 간에 디커플링 효과(탈 동조화)도 얻게 된다.
어플리케이션 코드 수정 한 줄 없이 mySQL을 SQLite로 바꿀 수 있다는 의미이다.

엘로퀀트 ORM의 꽃은 모델간의 관계 맺기

------------------------------

참고 사항

테이블 이름을 users 와 같이 복수로, 모델 이름은 User 처럼 단수로 하는 것이 규칙이다. DB 테이블은 Collection을 담고 있고, 모델은 DB 테이블에 담긴 하나의 레코드를 클래스로 표현한 것이기 때문이다. 규칙을 지킬 수 없는 경우에는, 가령 모델명을 Author, 테이블을 users 라 했을 경우, 라라벨이 둘 간의 관계를 알 수 있도록 Author 모델에 protected $table = 'users'; 코드를 추가해 주어야 한다.

쿼리를 배우기 위해 라라벨에서 제공하는 REPL 을 이용하자. tinker('어설프게 손보고 고치다' 라는 뜻)라고 불리는 artisan 커맨드인데, 라라벨의 모든 환경이 제공되기 때문에 여러가지 실험적인 시도들을 해보기 편리하다. ( DB 쿼리, 쿼리 빌더, 엘로퀀트 ORM도 연습 가능 ) 

-------------------------------

 쿼리 빌더 에서 사용할 수 있는 대부분의 메소드는 Eloquent Model에서도 사용할 수 있다. 
 예를 들면, App\Author::orderBy('id', 'desc')->limit(1)->lists('email');와 같이. 
 사실, 이번 강좌에서 보는 것은 엘로퀀트를 상속한 모델을 이용해서 쿼리 빌더를 쓸 수 있다는 정도이다. 
 엘로퀀트의 전부가 아니란 얘기다. 엘로퀀트 ORM의 꽃은 모델간의 관계 맺기이다.
 
 --------------------------------
 
    엘로퀀트는 모든 모델이 updated_at과 created_at 필드가 있다고 가정하고, 
    새로운 Instance가 생성될 때 현재의 timestamp값을 입력하려한다. 그런데, 수작업으로 만든 테이블들은 앞서 말한 
     필드들이 존재하지 않는다. 방법은 필드를 추가하는 방법과, timestamp 입력을 모델에서 끄는 방법이 있는데, 실습을 위해서 일단 꺼뒀음.
    // public $timestamps = false; 사
    
 모델에 변경이 생기면 실행중이던 tinker 를 다시 실행해 주어야 한다. tinker 가 로드될 시점에 라라벨 구동을 위한 모든 환경이 로드되므로, 이후 변경을 반영하기 위함이다. ctrl + C 또는 >>> exit 명령으로 종료할 수 있다.
 
 --------------------------------
 
 bcrypt(string $value) 은 암호화된 60byte스트링를 만들어 준다. Facade로 쓰면 Hash::make(string $value) 와 같다.
 
 암호화해주는 헬퍼 기능 함수임.
 
 -----------------------------
 
 라라벨의 구현한 객체 관계 맵퍼(ORM)인 엘로퀀트가 하는 역할입니다. 데이터베이스의 컬럼을 읽어와서 객체의 속성 값으로 채우거나, 반대로 객체의 속성을 데이터베이스 컬럼에 쓰는 역할을 합니다. 모델과 테이블 이름이 관례를 따를 때는 (모델:User, 테이블:users) 특별한 설정이 필요없으며, 다를 때는 모델:Author, 테이블:users 일때, Author 클래스에 public $tables = 'users'; 엘로퀀트에게 테이블 이름을 알려 주면 됩니다.
 
 --------------------------------
 
DB 마이그레이션

    마이그레이션은 데이터베이스를 위한 버전 컨트롤이라 생각하면 된다. 처음 테이블을 생성하고, 가령 이후에 새로운 필드를 추가한다든지, 필드의 이름을 바꾼다든지 등의 이력을 모두 마이그레이션 코드로 남겨 두고, 테이블을 생성했다가 롤백하는 등 자유롭게 이용할 수 있다.
    
    
    p.s
    
    대형 서비스라면 테이블 스키마를 변경해야 할 수도 있는 새로운 요구사항이 생길 수 있다. 이때 기초공사를 잘못해 두었다면, 개발자에게 엄청난 위기 상황이 닥칠 수도 있는데, 마이그레이션이 위기에서 개발자를 구해주는 데 도움을 줄 것이다. 정말로~ 그리고, 팀으로 여러 명이 테이블 스키마를 변경해 가면서 개발할 때는, mysqldump 해서 주고 받는 수고를 피하기 위해 꼭 필요하다.

사용자 추가 및 권한 추가 및 사용자 계정 삭제

https://cjh5414.github.io/mysql-create-user/

-----------------------------------

migration Reset & Refresh

migrate:rollback 이 직전 마이그레이션만 롤백하는 반면 migrate:reset 는 모든 마이그레이션을 롤백하고 데이터베이스를 초기화 시킨다. migrate:refresh 는 리셋을 실행해서 데이터베이스를 청소한 후, 마이그레이션을 처음부터 다시 실행하는 코맨드이다.

---------------------------------------

MVC 모델 뷰 컨트롤러

그중 C(컨트롤러)에 대해 살펴보자

컨트롤러가 필요한 이유

Route에 모든 비즈니스 로직을 넣을 수 없을 뿐더러, 코드를 효율적으로 구조화시키기 위해서 컨트롤러를 사용하여 구조화한 것이라 생각하면 된다.

--------------------------------

블레이드는 라라벨의 템플릿 엔진이다. 뷰 안에 포함된 블레이드 문법들은 블레이드 엔진에 의해 php 코드로 컴파일 된다.

{{}} - String interpolation 
    php echo 코멘트와 같은 역할을 해준다.  
    
{{-- --}} - Comment

    HTML 주석으로 컴파일 된다. 그런데 브라우저에서 소스보기로 보면 엄연히 다르다.
    
@foreach, @if, @forelse
    
@yield, @extends, @section - 마스터 레이아웃 사용하기

    @extends라는 키워드는 index.blade.php가 master.blade.php를 상속한다는 뜻이다. 또 @yield('content') 와 @section('content')를 주목하자. content라고 이름 지어진 섹션이 마스터 레이아웃에서 yield('양도하다', '넘겨주다' 라는 뜻) 된다는 의미다. 섹션은 원하는 숫자만큼 여러개 만들 수 있다. 뷰에서 만든 섹션의 이름으로 마스터 레이아웃에서 yield해 주기만 하면 된다. 

@include - 하위 뷰 포함하기

------------------------------------

라라벨은 CSRF(Cross Site Request Forgery) 공격을 방지하기 위해 기존 데이터를 변경하는 행위, 즉, 신규 생성, 업데이트, 삭제 등의 행위에 대해서는 CSRF 토큰을 폼요청에서 제공해야 한다. 가령 PostsController@create 메소드에서 응답한 모델 생성 폼에서 숨은 필드로 _token 값을 제공해야 한다. 폼 요청을 받은 PostsController@store 메소드는 토큰의 유효성을 확인하고, 같은 세션일 경우, 즉, create()를 요청한 클라이언트와 store()를 요청한 클라이언트가 동일할 경우에만 store() 액션을 수행한다. 
PostMan을 통해서 테스트하는 행위 자체가 CSRF 공격이라 볼 수 있다.

보안
HTTP 메소드를 사용할 때, 보안 측면을 고려하십시오. 더 강력한 보안을 위해, 일부 방화벽은 HTTP PUT 또는 DELETE 트래픽을 허용하지 않습니다.

-------------------------------------

중복된 Route의 경우, 항상 위에 정의된 것이 아래에 정의된 것을 오버라이드 한다. 가령 posts/count 라는 Route가 있다면 RESTful Resource 정의보다 먼저(== 위에) 정의하는게 안전하다.

--------------------------------------

"서로 다른 시스템간에 네트워크를 경유해서 데이터를 교환할 때 HTTP API 라는 것을 이용하는데, 아무렇게나 짜는 게 아니라, 기계 뿐 아니라 사람이 이해하기 쉽도록, 모두가 사용하고 권장하는 형태인 REST 원칙을 따르도록 짠 API" 가 "RESTful API" 인 것이다.

-------------------------------

중첩된 리소스
특정 리소스에 딸린 하위 리소스를 보여줘야 하는 경우가 있다. 가령, Post id 1번에 딸린 Comment 목록을 보여주거나, Comment를 생성/수정/삭제하는 경우 등이다.

리소스 컨트롤러 만들기

ex ) php artisan make:controller PostCommentController --resource

----------------------------------

http://haah.kr/2017/06/12/rest-the-big-lie/

나중에 실력 쌓이면 꼭 봐야할 사이트

------------------------------------

사용자 인증 기본기

좀 과장해서, 어떤 프로젝트든 로그인이 거의 업무량의 절반이라고들 한다. 그만큼 User 모델과 연결된 기능들이 많다는 의미로 이해하면 되겠다. 서비스에 들어온 사용자를 식별하는 방법을 인증(Authentication)이라 한다. 바꾸어 말하면, 사용자가 제시한 신분증이 DB에 저장된 User 정보와 동일한지 확인하고, 맞으면 통과시켜 주면서, 세션이라는 명찰을 하나 나눠 주는 행위라 이해할 수 있다.

    User 모델

        라라벨에는 User 모델과 마이그레이션이 이미 포함되어 있다. 
        app/User.php를 살펴보자.

-------------------------------------

AppServiceProvider.php 파일에 (DB마이그레이션 할 때)

use Illuminate\Support\Facades\Schema; // 이게 있어야 마이그레이션 가능


또한 MariaDB 또는 이전 버전의 MySQL 사용자는

AppServiceProvider.php 파일을 편집하고 수정해줘야 한다.

use Illuminate\Support\Facades\Schema;

public function boot()
{
    Schema::defaultStringLength(191);
}

https://laravel-news.com/laravel-5-4-key-too-long-error

------------------------------

로그인 뷰에서 소스보기를 해 보자. <input type="hidden" name="_token" value="jPR...nO2"> 란 라인을 볼 수 있다. 
바로 csrf_field() Helper Function이 CSRF 공격을 막기 위해 만든 토큰을 담은 숨은 입력 폼이다. 
13강에서 공부한 내용이다. {!! !!}은 '<', '>' 같은 특수문자의 '<', '>' Escaping 되는 것을 막기 위한 블레이드의 Interpolation 문법이다.

----------------------

라라벨에서 기본 제공하는 인증에서 패스워드는 최소 6자리 이상이어야 한다. 
App\Http\Controllers\Auth\RegisterController@validator 메소드를 보면 'password' => 'required|confirmed|min:6' 라고 
유효성 검사 규칙이 지정되어 있는 것을 확인할 수 있다. 유효성 검사, 뷰에 쓰인 old() 함수에 대해서는 뒤에서 다시 살펴보도록 하자.

--------------------

외래키 연결이 있는 관계에서 컬럼을 삭제할 수 없다.

migration 메소드 

	up 은 버젼 업데이트
	down 은 롤백에 사용

----------------

데이터 심기

앞에서 마이그레이션으로 테이블을 만들어 보았다. 만
들어진 테이블에 테스트 데이터 또는 기본 데이터를 심는 과정을 씨딩(Seeding)이라 한다. 
라라벨 5부터 Seeding을 효율적으로 하기 위한 Factory 기능이 제공된다. 
Factory는 데이터베이스 Seeding 뿐만 아니라, 테스트 클래스에서 필요한 데이터를 Stubbing하는데도 유용하게 사용할 수 있다.

factory() Helper 에서 호출한 make() 메소드는 메모리에 모델 인스턴스만 생성하는 반면, 곧 보게 될 create() 메소드는 모델 인스턴스를 생성하고 DB에 저장하는 일까지 한다.

factory() Helper Function을 이용해서 Seeder 클래스를 채우자. truncate() 메소드는 모델과 연결된 테이블 데이터를 깨끗이 지워주는 역할을 해 준다.

ex) // database/seeds/UsersTableSeeder
class UsersTableSeeder extends Seeder 
{
    public function run() 
    {
        App\User::truncate();
        factory('App\User', 10)->create();
    }
}

Seeder 클래스가 완성되었으면 마스터 Seeder 클래스인, database/seeds/DatabaseSeeder.php 에 등록하자. 
Model::ungard()는 모든 모델에 대해 MassAssignment를 허용한다는 의미이다.

-------------------

기본적으로 블레이드 {{ }} 문장은 XSS 공격을 방지하기 위해 PHP의 htmlspecialchars 함수를 통과합니다. 데이터를 escape 처리를 하지 않으려면 다음과 같이 작성하면 됩니다:

Hello, {!! $name !!}.

어플리케이션의 사용자들로 부터 입력하여 표시되는 컨텐츠를 출력할 때는 
escape-이스케이프에 대한 주의가 필요합니다. 
사용자가 제공한 데이터를 표시 할 때 XSS 공격을 방지하려면 항상 이스케이프 처리 된 이중 중괄호 문법을 사용하십시오.

------------------

eager loading
eager 로딩, 이거 로딩, 사전예약 로딩, 사전 로딩, 선행 로딩, 즉시 로딩
로딩시 참조해야 하는 정보를 미리 명시하는 일
N+1 쿼리 문제의 해결을 통해 성능 향상
ORM 활용시 흔히 발생할 수 있는 N+1 문제 해결 가능
게으른 로딩의 반대개념

Eager 로딩. 쿼리 갯수를 N+1에서 2개로 줄인다.
ORM 활용시 흔히 발생할 수 있는 N+1 문제 해결 가능

with(string|array $relations) 메소드는 항상 엘로퀀트 모델 바로 뒤, 다른 메소드를 체인하기 전에 써야 한다. 
메소드의 인자는 테이블 이름이 아니라, 모델 클래스에서 정의한 관계를 나타내는 메소드 이름임을 잘 기억하자.

ex)  Eager 로딩
Route::get('posts', function() {
    $posts = App\Post::with('user')->get();

    return view('posts.index', compact('posts'));
});

user 정보가 없어서 건수만큼 쿼리 추가 수행 (1+N회)
user 정보를 사용하겠다고 미리 알려줌으로써 쿼리 최소화 (2회)

Lazy Eager 로딩

가끔 엘로퀀트를 이용한 쿼리를 먼저 만들어 놓고, 나중에 관계를 로드해야 하는 경우가 발생할 수 있다. 
이때는 load(string|array $relations) 메소드를 이용할 수 있다.
(예를 들면, 쿼리 하나를 여러 번 재사용할 경우, 앞에서는 Eager 로딩이 필요없었지만, 나중에 필요하게 되는 경우 등이 해당된다. )

ex) 
Route::get('posts', function() {
    $posts = App\Post::get();
    $posts->load('user');

    return view('posts.index', compact('posts'));
});

-----------------------------

페이징

모델에 데이터가 많아지면 한번에 모든 레코드를 표시할 수가 없게 된다. 이때 필요한 것이 페이징이다.

app/Http/routes.php 에 아래와 같이 Route를 써 보자. 
모델에 대한 쿼리 끝에 get() 이나 find() 대신, paginate() 메소드를 체인하면 페이징을 위한 준비 완료! 
인자는 한번에 반환할 Collection 갯수를 넣는다. 이 예제에서는 10개로 했다.

Route::get('posts', function() {
    $posts = App\Post::with('user')->paginate(10);

    return view('posts.index', compact('posts'));
});

라라벨 페이징은 twitter bootstrap과 완벽하게 호환된다. 확인을 위해 resources/views/master.blade.php 에 bootstrap 사용을 선언하자.

20강에서 사용하던 resources/views/posts/index.blade.php 를 그대로 사용하자. 
@stop 바로 전에 아래 코드를 추가하자. paginate() 메소드를 체임함으로써, 
$posts 객체는 페이징이 가능한 Paginator 인스턴스로 변경되었고 render() 메소드를 쓸 수 있게 된 것이다. 
렌더링된 뷰에서 소스보기를 해서 어떤 코드가 추가되었는 지 확인해 보자.

@if($posts)
    <div class="text-center">
      {!! $posts->render() !!}
    </div>
  @endif
@stop

이 코드를 추가하고, 브라우저 소스보기와 비교해본다.
(직접 짜면 몹시 복잡한 페이지네이션 코드를 간단한 코드로 생성하였다.)

---------------

메일보내기

메일건 회원가입

.env 에서 MAIL로 시작하는 설정 전부 지우기
MAIL_DRIVER=smtp
MAIL_HOST=smtp.mailtrap.io
MAIL_PORT=2525
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null

메일을 보내 보자.
app/Http/routes.php 에 메일을 보내는 Route를 작성하자. 노파심에 다시 얘기하면, 학습을 위해 편의상 routes.php 에 작성하지만, 실전에서는 컨트롤러 (또는 서비스 로직)에 들어가야 하는 내용이다.

Route::get('mail', function() {
    $to = 'YOUR@EMAIL.ADDRESS';
    $subject = 'Studying sending email in Laravel';
    $data = [
        'title' => 'Hi there',
        'body'  => 'This is the body of an email message',
        'user'  => App\User::find(1)
    ];

    return Mail::send('emails.welcome', $data, function($message) use($to, $subject) {
        $message->to($to)->subject($subject);
    });
});
send() 메소는 3개의 인자를 받는다. 첫번째는 사용할 뷰, 두번 째는 뷰에서 바인딩 시킬 데이터, 세번째는 콜백이다.

참고 send() 대신 queue() 메소드를 사용하는 것이 편리하다. Queue 설정이 되어 있지 않으면, send()로 자동 폴백된다.

---------------------------

라라벨 이벤트 시스템은 Observer 또는 PubSub 패턴을 구현할 수 있게 해 준다.

이벤트 방식 구조체의 잇점 몇가지는 아래와 같다.

1. 사용자에게 빠른 응답을 제공할 수 있다. (Non blocking I/O)
2. 리스너를 여러개 구현하면, 이벤트 하나로 여러가지 작업을 동시에 수행할 수 있다.

이벤트는 주로 IO 가 수반되는 경우에 많이 사용된다. smtp 로 이메일을 보낸다든가, HTTP 클라이언트로 외부 서비스로 부터 데이터를 가져온다든가, 파일 시스템으로부터 큰 파일을 읽을 때 등이 대표적인 예이다.

-----------------------------

입력 값 유효성 검사

항상 듣는 말이다. "사용자가 입력한 값은 절대 신뢰하지 마라." 
유효성 검사는 사용자의 악의적인 해킹 시도 또는 잘못된 데이터 입력으로 부터 
서비스를 보호하는 기본 중에 기본이므로 굉장히 중요하다. 

프론트엔드에서 자바스크립트로 한번 걸렀다고 해도, HTTP 클라이언트를 통해서 직접 요청할 수 있으므로 백엔드에서도 반드시 유효성 검사를 수행해야 한다.

라라벨이 지원하는 유효성 검사 규칙
required, min 뿐 아니라, string, confirmed, exists, required_if, 
등등등 굉장히 많다. 공식 문서를 참고하자.

https://laravel.com/docs/5.6/validation#available-validation-rules

$errors 변수는 모든 뷰에서 항상 존재하기 때문에 if (isset($errors)) 등과 같은 방어 조치를 할 필요가 없다는 것을 기억해 두자. $errors는 withErrors()에 의해 세션에 구워진 값이다.

***Form Request를 이용하는 방법이 가장 깔끔하긴 하다. 공식 문서를 참고하자.

--------------------------------------

예외 던지기

라라벨에서 예외(Exception)는 컨트롤러 또는 서비스 로직을 수행하는 도중 
어디서든 던질 수 있다. 
app/Http/routes.php를 이용하여 예외를 던지는 방법은 실습해 보자.

ex)

Route::get('/', function() {
    throw new Exception('Some bad thing happened');
});

Production 환경에서는 보안을 위해 Stack Trace가 모두 찍히는 DEBUG 옵션을 꺼야 한다. .env 파일에서 APP_ENV=production, APP_DEBUG=false로 바꾼 후 '/' Route를 다시 방문해 보자. 웹 서버를 재시작해야 변경 내용을 확인할 수 있다.

또 다른 방법은 abort(404) 처럼, abort(int $code, string $message) Helper Function을 이용하는 방법이다. abort()는 HttpException 을 던진다.

------------------------------------------

예외를 캐치하자.

라라벨에서는 try{} catch($e){} 로 감싸지 않아도, 글로벌 하게 예외를 잡아준다. 
바로 app/Exceptions/Handler.php 가 주인공이다. 클래스를 살펴보자.

class Handler extends ExceptionHandler
{
    protected $dontReport = [];

    public function report(Exception $e) {}

    public function render($request, Exception $e) {}
}

$dontReport 속성에는 report() 메소드를 타지 않을 예외 클래스들의 리스트를 정의한다.

report() 메소드는 기본적으로 로그 (storage/logs/laravel.log)에 예외의 내용을 쓴다. 여기서 관리자 이메일, 슬랙, BugSnag와 같은 외부 서비스에 예외 내용 등을 리포트하는 로직을 더 구현해 넣을 수 있다.

render() 메소드에서는 예외를 Http 응답으로 렌더링하는 로직들을 포함한다.

--------------------------------------------

예외를 처리하자.

app/Exceptions/Handler.php의 render() 메소드에 처리 내용을 추가해 보자. 

아래는 ModelNotFoundException 이 발생하면 지정된 뷰를 내용으로 하는 
HTTP 404 응답을 반환하라는 의미이다.

ex)

class Handler extends ExceptionHandler
{

public function render($request, Exception $exception)
    {
        // 예외를 처리하자.
        if ($exception instanceof \Illuminate\Database\Eloquent\ModelNotFoundException) {
            return response(view('errors.notice', [
                'title'       => 'Page Not Found',
                'description' => 'Sorry, the page or resource you are trying to view does not exist.'
            ]), 404);
        }
        return parent::render($request, $exception);
    }
}

---------------------------------

컴포저

Composer는 php의 패키지 매니저이다. 패키지 레지스트리는 패키지스트라 불린다. 
Java에 Maven, Python에 PyPi, Ruby에 Gem, Node에 Npm이 있다면, php엔 Composer가 있다. 라라벨도 버전 4로 넘어가면서 Composer를 본격적을 도입하고, 
코어 프레임웍과 외부 패키지로 분리했다.

작은 서비스를 개발할 때는 패키지를 관리하는 일이 필요없지만, 서비스가 커질 수록 패키지 관리의 필요성은 급증한다. 급기야 패키지를 관리하지 않아서, 개발자들이 패키지에 의해서 관리 당해지는 웃지 못할 사태가 벌어질 수 있다. 패키지 매니저를 쓸 때 개인적으로 좋은 점을 정리해 봤다.

기억력을 보조한다 (레지스트리 역할).
이미 만들어진 바퀴를 쉽게 가져다 쓰고, 모양을 약간 바꾸어 쓸 수도 있다 (Code Reuse).
외부 패키지들은 버전 관리에서 빠지기 때문에 코드 풋프린트가 줄어들고 Git에 푸시 할 때 빠르다.
외부 패키지들의 업데이트를 자동화할 수 있다. 즉, 일일이 확인하고, 다운로드하고, 설치해 줄 필요 없다.


패키치 설치법

    cmd 창에
    composer require "설치할 패키지(검색해서 알아서 찾기)"

    p.s - 프로젝트 디렉토리에 위치한 composer.json 파일을 열고, require 섹션에 필요한 패키지를 직접 추가해 준 후, $ composer update 코맨드를 실행하는 방법으로도 설치할 수 있다.

어디에 어떤 패키지가 있는 지 어떻게 알아요?

    유용성, 인기도, 완성도 측면에서 검증되어 큐레이션된 패키지 들이 있는 곳을 소개한다. 필요한 기능이 있다면 직접 만들려 하지 말고, 이 목록을 탐색하고 구글링해 보자.

        ziadoz/awesome-php
        chiraggude/awesome-laravel
        TimothyDJones/awesome-laravel

---------------------------------

Document 모델

마크다운 문서들은 docs 같은 폴더에 위치하고 있다. 
생각해 보면, DB 테이블에서 데이터를 가져오는 것이 아니라, 
파일시스템에서 가져와야 한다. 파일시스템에 접근하는 방법을 알아 보자.

File vs Storage

    라라벨에서 File과 Storage 2개의 Facade가 있다. 공식문서에서 File이 빠진 것으로 보아 Storage의 사용을 권장하는 것처럼 보인다. 두 Facade의 API(== public 메소드)는 거의 동일하지만, Storage는 파일 저장위치를 config/filesystems.php 에 지정해 놓으면 그 디렉토리 밖을 벗어날 수 없다. 우리의 docs 폴더는 프로젝트 루트에 위치하므로, File Facade를 이용해야 한다.

참고 

    put(string $path, string $contents) 파일 쓰기, files(string $directory) 파일 목록 가져오기, glob(string $pattern) 패턴에 맞는 파일 목록 가져오기, isDirectory(string $directory) 디렉토리 체크, makeDirectory(string $path, int $mode) 디렉토리 만들기 등은 실전에서 자주 사용하게 되니 사용법을 익혀 두자.

Document 모델을 만들자.

    $ php artisan make:model Document

    Document 모델은 엘로퀀트를 상속하지 않는다. 잘 생각해 보면, 컨트롤러의 기본 동작인 CRUD(Create, Read, Update, Delete) 중 Read만, 즉, 컨트롤러에서 요청한 이름에 해당하는 파일을 잘 읽어서 반환해 주는 메소드 하나만 필요하다.
    
    
*** 예외 처리 하는 곳  >> app/Exceptions/Handler.php << 

---------------------------

커스텀 Helper Function 만들기
 
1. app/helpers.php 만들기.(파일에는 사용할 헬퍼함수 작성)

2. 라라벨이 부트업될 때 helpers.php 파일도 포함시키기 위해,
    composer.json에 files 엔트리를 추가한다.
 
    ex) "autoload": {
        "classmap": ["..."],
        "files": ["app/helpers.php"],  
        "psr-4": {"...": "..."},
        },

3. autoload 파일을 refresh 하기 위해 아래 커맨드를 수행한다.
    
    $ composer dump-autoload

    # autoload가 잘 되었는지 tinker 로 테스트해 보자
    $ php artisan tinker
    >>> markdown('**bold**');
    => "<p><strong>bold</strong></p>"
    
4. Document 컨트롤러 만들기

5. Route 정의

6. 뷰 만들기

7. 서버를 띄우고 뷰에 잘 뿌려지는지 확인

8. 끝

-----------------------------

Cache

캐시는 HTTP 요청에 대한 응답을 파일 또는 메모리에 저장해 두었다가 두번째 요청부터는 저장소에서 바로 꺼내어 주는 기능이다. 

우리가 사용한 마크다운 파일은 자주 변경되지 않는다. 
즉, 매번 사용자가 요청할 때 마다 모델에서 요청한 파일을 읽어 들이고, ParsedownExtra 클래스 인스턴스를 만들어서 text() 메소드를 호출한다는 것은 서버의 CPU 및 메모리 자원뿐만아니라 사용자의 시간을 낭비하는 일이다. 
이럴 때 필요한 것이 서버측 캐시이다. 

데이터베이스 드라이버와 마찬가지로 라라벨 캐시도 다양한 드라이버를 지원한다.
    
1. 캐시 설정
    .env 와 config/cache.php를 열어서 기본 캐시 드라이버 설정을 확인하자. file 드라이버를 사용하고 있고, 캐시 저장소는 storage/framework/cache 인 것을 알 수 있다. 우선 실습을 위해 file 드라이버를 그냥 사용하도록 하자.
    (현재 버젼은 캐시 저장소가 storage/framework/cache/data 로 되어있음.)

2. 컨트롤러에 캐시 기능 추가
    DocumentsController::show() 메소드를 수정할 것이다. 
    캐시는 key => value 저장소라는 것을 기억하자.

    Cache Facade 를 이용한다.

    remember() 메소드의 첫번째 인자는 키 이름이다. 이 키 이름으로 데이터를 저장할 것이다. 

    두번째 인자는 캐시를 유지할 시간이다. 

    키 이름에 해당하는 값이 캐시 저장소에 없으면, 세번째 인자로 받은 콜백을 실행한다. 
    
    이 콜백에서 반환되는 값을 캐시 키 값으로 해서, 두번째 인자로 지정된 시간만큼 캐시 저장소에 가지고 있는다. 
    
    지정된 시간 내에 들어온 요청에 대해서는 세번째 인자인 콜백을 실행하지 않고, 캐시 저장소에서 키 값에 대응되는 값(value)를 찾은 후 반환하는 식이다.

        ex) 첫 캐시가 적재된 이후 2시간 동안은 캐시에서 바로 응답하도록 했다면?
        가령, 8시 정각에 첫 요청이 들어와 새로운 캐시가 생성되었다면, 10시까지는 캐시에서 응답을 하다가, 10시 1초 이후에 요청이 들어오면 다시 콜백을 수행하고 캐시 저장소에 키와 값을 적재하게 된다. (무슨 얘긴지 이해 되었기를 바라는 마음에서 반복해서 설명했다.)
    
    
    참고
    
    어떨 때는 클래스 앞에 \ 를 쓰고 어떨 때는 안 쓰고 왜 그래요?" 
    "일부러 쓸 수도 있다." \는 루트 네임스페이스를 의미한다. 
    우리 컨트롤러는 App\Http\Controllers 네임스페이스 아래에 위치한다. 
    컴퓨터에서 절대경로와 상대 경로를 얘기할 때랑 마찬가지로, Cache라고 그냥 쓰면, App\Http\Controllers\Cache를 의미하게 되고(상대 경로), 그런 클래스는 존재하지 않는다. 해서 루트 (\) 네이스페이스에 존재하는 Cache 라고 명시적으로 쓴 것이다. 
    
    클래스를 시작하기 전에 use 키워드로 전체 경로를 표시해 주면 \를 생략할 수 있다.
    (이는 네임스페이스가 있는 모든 언어 마찬가지다. Java의 경우 use 대신 import를 사용한다. import org.apache.http.client.HttpClient 처럼.)
    
    수동으로 캐시 지우기
    
    artisan CLI를 이용해 수동으로 지워 보자. 
    변경이 생기면 이벤트를 던져서 캐시를 초기화하는 것은 뒤에 다시 배운다.

    $ php artisan cache:clear
    
    캐싱은 Redis!!! 추후 공부할 것.
        
------------------------------

Caching을 시작하기 전에 "적정 기술" 이란 개념에 대해 먼저 잡담을 좀 하자.

적정 기술이란 비즈니스/서비스의 성숙도나 규모에 따라 적합한 기술을 선택하는 행위로 해석한다. 스타트업이 MVP (==Minimum Viable Product) 를 개발하는 데, 
Caching 까지 고려해서 할 필요는 없다는 얘기다. 
일 Page View 가 몇 천, 피크 타임에 동시 사용자가 수십 명 정도인 서비스에 Caching 까지 
고려해서 API 서버와 API 클라이언트를 개발할 필요는 없다는 얘기다.

바꾸어 얘기하면, 트래픽이 많은 서비스는 서버 사이드 및 클라이언트 사이드 모두에서 캐시를 구현해야 한다는 얘기다. 좀 더 나아가서 서버 팜에는 L4, Web, DB, Cache 등 서버가 모두 분리되어 있고 오토스케일링 할 수 있도록 설정되어 있어야 하며, Session 이나 Cache 등 공용 저장소는 클러스터링이 되어 있어야 한다. 규모가 되었는데 이렇게 안하면, 사용자는 떠나고 사업은 망한다.

지금 내가 처한 상황에서 Caching 이 적정기술이 아니더라도, 이 강좌는 일단 학습 목적으로 배워 두자. 그리고, "아, 그거 거기에 있었지~" 정도로 기억해 두자, 필요할 때 꺼내 쓸 수 있도록. "페이스북 하니까..", "구글이 하니까.." 라고 하는 오류를 범하지 말자.

--------------------------------

AWS, 서버관련 학습

ELB

Elastic Load Balancing의 약자로 시스템에 가해지는 부하를 여러대의 시스템으로 분산해서 규모있는 시스템을 만들 수 있도록 해주는 단일 진입점

대량의 트래픽을 분산시켜준다.

Scale

서비스의 흥행상황은 항상 유동적이다. 접속자가 많을 때도 있고, 적을 때도 있다. 어떤 서비스는 완만하게 성장하는 경우도 있고, 어떤 서비스는 특정 시간에 접속이 집중될수도 있다. 수강신청이나 귀성길 열차예매와 같은 업무를 처리하는 시스템이 그렇다. 예측하지 못한 순간에 시스템에 폭주하는 경우도 있다. 이런 상황은 물론 비즈니스의 관점에서는 행복한 순간이라고 할 수 있겠지만, 이에 대한 준비가 되어 있지 않다면 이것은 비즈니스적인 클라이막스를 두손 놓고 보내버리는 수 밖에 없다. 그렇다고 평소에 충분한 시스템을 준비하기에는 돈이 없다. 이런 상황에서 사용할 수 있는 서비스가 EC2와 ELB이다. EC2로 손쉽게 인스턴스를 생성하고, 이것을 ELB로 묶어서 서비스를 제공한다.

Auto Scaling
Auto scaling이란 정책에 따라서 시스템을 자동으로 늘리고 줄여주는 서비스다. 이를테면 이런식으로 동작한다. 갑자기 트래픽이 폭주하면 서비스에 참여하고 있던 서버들의 CPU 사용률이 점점 높아진다. 그러다 CPU 점유율이 80%를 넘게되면 미리 준비된 이미지(AMIs)를 이용해서 인스턴스를 생성하고, ELB에 연결해서 트래픽을 새로 생성한 EC2 인스턴스에 분산한다. 트래픽이 줄어들면서 CPU 사용률이 20% 아래로 떨어지면 EC2 인스턴스가 순차적으로 제거된다. 비용을 절감할 수 있다.


캐싱 관련된 용어 참고

- 오토스케일링 

- 클러스트링 : 특징이 같은 데이터끼리 묶어줌, 군집화

---------------------------------

LARAVEL MIX !! - (구) Elixir, 만병통치약?

    Elixir('엘릭서'라 읽음)은 만병통치약을 뜻하는 단어이다. 
    라라벨의 Elixir란 이름은 어디에서 유래되었는 지 모르겠다. 
    Elixir는 여러 기능을 가지고 있지만, 함축하자면 프론트엔드 리소스, 
    그러니까 CSS 와 Javascript 같은 리소스의 빌드를 자동화하는 도구라고 생각할 수 있다. 
    여기서 말하는 빌드란 Minification, CSS Vendor Prefixing, 여러 파일 병합,   Sass/Less/Coffee/Babel 스크립트의 컴파일, ... 등을 의미한다. 
    프론트엔드 빌드 자동화를 수행하는 구현체는 Ruby on Rails 에서 Asset Pipeline 이란 
    이름으로 세상에 먼저 소개되었고, 이후 Django Pipeline 등 
    여러 프레임웍에서 따라한 것으로 필자는 알고 있다. 라라벨도 그중 하나!!

    라라벨 5 버전이 출시되고 Elixir 가 공개되기 이전에 개발자들은 Gulp나 Grunt를 이용하여 빌드 자동화 스크립트를 작성해 왔다. 하지만 라라벨 5의 Elixir는 기존 빌드 스크립트들의 복잡함과 어려움을 극도로 단순화하여, 초보자도 쉽게 사용할 수 있는 API를 제시하고 있다. (그럼에도 불구하고, 여전히 어렵고 복잡하다.)
    
*** 라라벨 5.4 이상부터 Elixir가 Webpack 에 의존하는 
    더 간단한 Laravel Mix로 바뀌었다!!!

Laravel Elixir가 Laravel Mix로 명칭 변경됨

필요한 프론트엔드 리소스를 정의하자!

    우리 프로젝트에 필요한 프론트엔드 리소스는 무엇인가? 
     
ex)     Twitter Bootstrap
        FontAwesome
        resources/assets/sass/app.scss
        resources/assets/js/app.js
        위에 나열된 2개의 외부 의존성과 내가 만든 2개의 리소스에 대한 
        빌드 자동화 방법을 생각해보자!

컴파일이란? 

    쉽게말하면 변환을 하는 것이다. 우리가 흔히 쓰는 언어들은 인간지향적으로 설계되어 있다.
    인간이 보기 편하게 만든 소스코드를 컴퓨터가 이해 할 수 있도록 기계지향적 언어로
    변환하는 방법이 컴파일이다.
    
    인간지향적 언어에서 기계지향적 언어로 바꾸는 일과 그 반대의 일 모두 컴파일이라 불린다.
    그리고 컴파일은 변환이고 컴파일러는 변환기라고 보면 된다.
    
-------------------------------------

    정규 표현식
    
        \p 또는 \P에 한 문자만 지정하면 해당 문자로 시작하는 모든 속성이 포함한다. 
        \P{xx}	xx 속성을 가지지 않는 문자
        \p{xx}	xx 속성을 가지는 문자
            N	숫자(Number)
            L	문자(Letter)
            
        대괄호 안에 있는 패턴의 일부를 캐릭터 클래스 라고 한다. 캐릭터 클래스에서 사용할 수 있는 메타 문자는 다음과 같다.
        
            \	일반 이스케이프 문자
            ^	캐릭터 클래스를 반전(단, 첫 번째 문자로 입력될 때)
            -	문자 범위
            ]	캐릭터 클래스를 종료
            
            
        {2} {} 는 수량자이다. Quantifier. 정확히 2번 찾아준다.
        
            ex )  [0-9]{2} 숫자 2개 찾아줌.
            
        정규표현식 예제 : (?P<parent>[0-9]{2}-[\pL-\pN\._-]+)-(?P<suffix>image-[0-9]{2}.png)
        
            01-welcome-image-01.png
            03-hou-image-02.png 
            04-.-image-01.png
            04-_-image-02.png
            05---image-04.png 다 찾아짐
            
                (?P) 는 Named Capture Group
                Named Capture Group 사용법 >>> (?P<그룹명>정규식)


잠시 정규표현식을 복습해보았다.
    
------------------------

클래스와 네임 스페이스에 관한 가장 쉽고 가장 깔끔한 설명 + 의존성

https://www.haruair.com/blog/2843#comment-4149

----------------------

의존성 원칙

PHP는 현재의 namespace에 따라 상대적으로 동작한다.

<?php
namespace Haruair;

$edward = new Edward();

Haruair 네임스페이스 내에서 개체를 생성했다. 동일한 네임스페이스에 속해 있는 상황이기 때문에 
Haurair\Edward를 Edward로 호출해 사용할 수 있다.

